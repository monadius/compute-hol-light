(* load_path := "/Users/monad/Work/git/formal_ineqs" :: !load_path;; *)
needs "tame_defs.hl";;
needs "tame_defs_unrolled.hl";;
loadt "test_tame_support.hl";;

let rules = [
  "APPEND_UNROLL8", APPEND_UNROLL8, [];
  "map_of_DEF", map_of_DEF, [];
  "the_DEF", the_DEF, [];
  "is_none_DEF", is_none_DEF, [];
  "funpow_UNROLL5", funpow_UNROLL5, [];
  "nth_UNROLL15", nth_UNROLL15, [];
  "fold_DEF", fold_DEF, [];
  "rev_DEF", rev_DEF, [];
  "upt_DEF", upt_DEF, [];
  "zip_ALT", zip_ALT, [];
  "null_DEF", null_DEF, [];
  "last_DEF", last_DEF, [];
  "maps_UNROLL7", maps_UNROLL7, [];
  "foldl_DEF", foldl_DEF, [];
  "foldr_ALT", foldr_ALT, [];
  "concat_DEF", concat_DEF, [];
  "filter_DEF", filter_DEF, [];
  "member_DEF", member_DEF, [];
  "rotate1_DEF", rotate1_DEF, [];
  "rotate_ALT", rotate_ALT, [];
  "bool_to_num_DEF", bool_to_num_DEF, [];
  "count_UNROLL7", count_UNROLL7, [];
  "hd_DEF", hd_DEF, [];
  "tl_DEF", tl_DEF, [];
  "list_ex_DEF", list_ex_DEF, [];
  "remdups_DEF", remdups_DEF, [];
  "remove1_DEF", remove1_DEF, [];
  "map_UNROLL11", map_UNROLL11, [];
  "pred_list_UNROLL11", pred_list_UNROLL11, [];
  "replicate_DEF", replicate_DEF, [];
  "gen_length_DEF", gen_length_DEF, [];
  "map_filter_ALT", map_filter_ALT, [];
  "list_update_DEF", list_update_DEF, [];
  "all_interval_nat_DEF", all_interval_nat_DEF, [];
  "size_list_UNROLL15", size_list_UNROLL15, [];
  "fst_DEF", fst_DEF, [];
  "snd_DEF", snd_DEF, [];
  "mapAt_DEF", mapAt_DEF, [];
  "splitAtRec_DEF", splitAtRec_DEF, [];
  "splitAt_DEF", splitAt_DEF, [];
  "between_ALT", between_ALT, [];
  "minimall_ALT", minimall_ALT, [];
  "replace_DEF", replace_DEF, [];
  "removeKey_DEF", removeKey_DEF, [];
  "removeKeyList_DEF", removeKeyList_DEF, [];

  "vertices_face_DEF", vertices_face_DEF, [];
  "final_face_DEF", final_face_DEF, [];
  "faceListAt_DEF", faceListAt_DEF, [];
  "facesAt_DEF", facesAt_DEF, [];
  "tri_ALT", tri_ALT, [];
  "quad_ALT", quad_ALT, [];
  "faces_DEF", faces_DEF, [];
  "graph_ALT", graph_ALT, [];
  "degree_DEF", degree_DEF, [];
  "except_ALT", except_ALT, [];
  "finals_DEF", finals_DEF, [];
  "heights_DEF", heights_DEF, [];
  "height_DEF", height_DEF, [];
  "nextElem_ALT", nextElem_ALT, [];
  "setFinal_DEF", setFinal_DEF, [];
  "nextVertex_ALT", nextVertex_ALT, [];
  "neighbors_DEF", neighbors_DEF, [];
  "nonFinals_DEF", nonFinals_DEF, [];
  "vertextype_DEF", vertextype_DEF, [];
  "finalVertex_DEF", finalVertex_DEF, [];
  "final_graph_ALT", final_graph_ALT, [];
  "nextVertices_DEF", nextVertices_DEF, [];
  "countVertices_DEF", countVertices_DEF, [];
  "directedLength_DEF", directedLength_DEF, [];
  "vertices_graph_DEF", vertices_graph_DEF, [];

  "tame10_ALT", tame10_ALT, [];
  "tame11a_DEF", tame11a_DEF, [];
  "tame11b_DEF", tame11b_DEF, [];
  "tame12o_ALT", tame12o_ALT, [];
  "tame10ub_DEF", tame10ub_DEF, [];
  "excessTCount_DEF", excessTCount_DEF, [];
  "squanderTarget_DEF", squanderTarget_DEF, [];
  "squanderFace_ALT", squanderFace_ALT, [];
  "squanderVertex_ALT2", squanderVertex_ALT2, [];
  "maxGon_DEF", maxGon_DEF, [];
  "seed_DEF", seed_DEF, [];
  "duplicateEdge_DEF", duplicateEdge_DEF, [];
  "containsUnacceptableEdgeSnd_ALT", containsUnacceptableEdgeSnd_ALT, [];
  "containsUnacceptableEdge_ALT", containsUnacceptableEdge_ALT, [];
  "containsDuplicateEdge_DEF", containsDuplicateEdge_DEF, [];

  "alist_DEF", alist_DEF, [];
  "values_DEF", values_DEF, [];
  "lookup_ALT", lookup_ALT, [];
  "rem_alist_DEF", rem_alist_DEF, [];
  "update_ALT", update_ALT, [];

  "minimalFace_ALT", minimalFace_ALT, [];
  "minimalVertex_DEF", minimalVertex_DEF, [];
  "listSum_DEF", listSum_DEF, [];
  "heightsNewVertices_DEF", heightsNewVertices_DEF, [];
  "replacefacesAt_DEF", replacefacesAt_DEF, [];
  "split_face_ALT", split_face_ALT, [];
  "splitFace_ALT", splitFace_ALT, [];
  "makeFaceFinalFaceList_DEF", makeFaceFinalFaceList_DEF, [];
  "makeFaceFinal_DEF", makeFaceFinal_DEF, [];
  "subdivFacea_ALT", subdivFacea_ALT, [];
  "subdivFace_DEF", subdivFace_DEF, [];

  "enumAppend_DEF", enumAppend_DEF, [];
  "enumBase_DEF", enumBase_DEF, [];
  "enumerator_ALT", enumerator_ALT, [];
  "enum_ALT", enum_ALT, [];

  "hideDupsRec_DEF", hideDupsRec_DEF, [];
  "hideDups_DEF", hideDups_DEF, [];
  "indexToVertexList_DEF", indexToVertexList_DEF, [];
  "notame_DEF", notame_DEF, [];
  "excessAtType_ALT", excessAtType_ALT, [];
  "excessAt_DEF", excessAt_DEF, [];
  "faceSquanderLowerBound_DEF", faceSquanderLowerBound_DEF, [];
  "deleteAround_ALT", deleteAround_ALT, [];
  
  "excessNotAtRec_ALT", excessNotAtRec_ALT, [];
  "excessTable_ALT", excessTable_ALT, [];
  "excessNotAt_ALT", excessNotAt_ALT, [];
  "squanderLowerBound_DEF", squanderLowerBound_DEF, [];
  "polysizes_ALT", polysizes_ALT, [];
  "is_tame13a_ALT", is_tame13a_ALT, [];
  "generatePolygonTame_ALT", generatePolygonTame_ALT, [];
  "next_tame0_ALT", next_tame0_ALT, [];
  "is_tame_DEF", is_tame_DEF, [];
  "next_tame_ALT", next_tame_ALT, [];
  "worklist_tree_aux_DEF", worklist_tree_aux_DEF, [];
  "worklist_tree_ALT", worklist_tree_ALT, [];
  "nof_vertices_ALT", nof_vertices_ALT, [];

  "qsort_DEF", qsort_DEF, [];
  "hash_ALT", hash_ALT, [];
  "fgraph_DEF", fgraph_DEF, [];
  "merge_ALT", merge_ALT, [];
  "compat_DEF", compat_DEF, [];

  "pr_iso_test_rec_ALT", pr_iso_test_rec_ALT, [];
  "pr_iso_test_DEF", pr_iso_test_DEF, [];
  "iso_test_DEF", iso_test_DEF, [];
  "insert_mod_trie_ALT", insert_mod_trie_ALT, [];
  (* "insert_mod2_trie_DEF", insert_mod2_trie_DEF;
  "worklist_tree_coll_aux_trie_ALT", worklist_tree_coll_aux_trie_ALT;
  "worklist_tree_coll_trie_DEF", worklist_tree_coll_trie_DEF;
  "enum_filter_finals_ALT", enum_filter_finals_ALT; *)
  "tameEnumFilter_ALT", tameEnumFilter_ALT, [];

  "worklist_tree_bounded_ALT", worklist_tree_bounded_ALT, [];
  "tameEnumFilterBounded_DEF", tameEnumFilterBounded_DEF, [];
];;

let db = add_thms (tame_default_db ()) rules;;
let consts = dependencies db `tameEnumFilterBounded`;;
(* TODO: doesn't work: extra dependencies for fixed constants are produced *)
(* let consts = dependencies db `tameEnumFilterBounded` ~inst_types:false *)
set_extra_for_consts db Extra_memo [
  (* `bool_to_num`; *)
  `squanderFace`;
  `maxGon`;
  (* `fst:num#num->num`; *)
  (* `is_none:(num#num)option->bool`; *)
  (* `final_face`; *)
  `size_list:(num)list->num`;
  `excessAtType`;
  `squanderVertex`;
  `vertices_face`;
  `heightsNewVertices`;
  `upt`;
  (* `nextElem:(num)list->num->num->num`; *)
  `nextVertex`;
  `rev:(num)list->(num)list`;
  `APPEND:(num)list->(num)list->(num)list`;
  `nextVertices`;
  `member:(num)list->num->bool`;
  `enum`;
  (* `nth:(num)list->num->num`; *)
  (* `faceListAt`; *)
  `splitAtRec:num->(num)list->(num)list->(num)list#(num)list`;
  `map:(num->(num)list)->(num)list->((num)list)list`;
  `map:((num)list->(num)list)->((num)list)list->((num)list)list`;
  (* `filter:(num#num->bool)->(num#num)list->(num#num)list`; *)
  `removeKeyList:(num)list->(num#num)list->(num#num)list`;
  (* `nth:((face)list)list->num->(face)list`; *)
  (* `excessNotAtRec`; *)
];;

let () =
  set_extra_for_all db Extra_counter;
  (* set_rule db `(=):A->A->bool`; *)
  (* set_extra_for_all db Extra_arg_list; *)
  (* write_rules_names db "out.hl" const_names *)
  write_rules_consts db "out.hl" consts;;
loadt "out.hl";;

(* 40.714s *)
(* original: 0.0171s *)
(* ratio: 2381 *)

(* 26.144s with COND instead of AND/OR *)
(* 25.406s with new AND/OR *)
(* 23.614s with size_list_ALT with 15 cases *)
(* 18.631s with custom types (COND, f_EQ still use INST_TYPE) *)
(* 17.927s with custom types (including COND but without f_EQ) *)
(* 17.995s with custom types everywhere *)
(* 14.663s with nth_ALT with 10 cases *)
(* 14.538s with funpow_ALT2 with 5 cases *)
(* 14.487s with maps_ALT, count_ALT, map_ALT, pred_list_ALT *)
(* 9.915s with fast arithmetic *)
(* 9.859s with fast arithmetic + standardize *)
(* 9.797s with APPEND_UNROLL8 *)
(* 9.653s with nth_UNROLL15, maps_UNROLL7, count_UNROLL7 *)
(* 8.874s with memos *)
reset_all_counters();;
(* reset_core_counters();; *)
clear_arg_lists();;
clear_all_memos();;
test 1 (f_tameEnumFilterBounded (numeral `0`)) (numeral `100`);;
test 1 (f_tameEnumFilterBounded `0`) `100`;;

(* New orda improves performance *)
(* type_of 5566376 *)
(* type_of 2913467 with new MK_COMB *)
(* No significant difference in performance *)
core_counters();;
reset_core_counters();;

time (f_tameEnumFilterBounded `0`) `100000`;;
setify_types !eq_types;;

get_all_counters();;
get_counter "f_gen_length";;
Hashtbl.fold (fun k v r -> k :: r) (create_memo "f_size_list") [];;

(* nth -> unroll up to 15 *)
(* maps -> up to 7 *)
(* count -> up to 7 *)

analyze_arg_lists();;

let args = lazy !(create_arg_list "f_squanderVertex");;
let n = Lazy.force args |> length;;
Lazy.force args |> map (length o dest_list o el 0) |> freqs;;
Lazy.force args |> map (Nat_arith.dest_nat o el 0) |> freqs;;
Lazy.force args |> freqs;;
let t = Lazy.force args |> freqs |> length;;
float (n - t) /. float n;;

Nat_arith.reset_cache();;

setify !cond_types |>
  map (fun ty -> ty, fix_identifier @@ string_of_type ty);;

(* set_extra db Extra_memo ["size_list"];; *)
generate_call_counters := true;;


needs "out.hl";;
compile_term db "t" `pred_list (\x. x <= 10) [1;2;4;3]` |> print_expr Format.std_formatter;;
compile_term db "t" `map_filter (\x. if x <= 10 then SOME (x + 2) else NONE) [1;2;4;3]` |> print_expr Format.std_formatter;;

let tm = Nat_arith.replace_numerals `Graph [] 0 [[Face [1;2] Final]; [Face [3] Nonfinal]] [1;2]`;;
let tm2 = rand (concl (f_graph `N4 _0`));;

f_is_none `NONE`;;
f_between `[1;2;3]` `1` `3`;;

f_tri `Graph [] 0 [[Face [1;2] Final]; [Face [3] Nonfinal]] [1;2]` `1`;;
f_facesAt tm `1`;;
f_degree tm2 `1`;;
f_except tm2 `1`;;
f_finals tm2;;
f_heights tm;;
f_height tm `1`;;
f_nextElem `[1;2;3]` `0` `2`;;
f_setFinal `Face [1;2] Nonfinal`;;
f_nextVertex `Face [1;2;3;4] Final` `4`;;
f_neighbors tm2 `2`;;
f_nonFinals tm2;;
f_vertextype tm2 `1`;;
f_finalVertex tm2 `0`;;
f_final_graph tm2;;
f_nextVertices `Face [1;2;3;4] Nonfinal` `3` `2`;;
f_countVertices tm2;;
f_directedLength `Face [1;2;3;4] Nonfinal` `1` `2`;;
f_vertices_graph tm2;;
f_tame10 tm;;
f_tame11a tm2;;
f_tame11b tm2;;
f_tame12o tm2;;
f_tame10ub tm2;;
f_excessTCount;;
f_squanderTarget;;
f_squanderFace `1`;;
f_squanderVertex `1` `20`;;
f_maxGon `3`;;
f_seed `0`;;
f_duplicateEdge tm2 `Face [1;2] Nonfinal` `1` `2`;;
f_containsUnacceptableEdgeSnd (`>`, f_GT) `1` `[1;2;3;4;5]`;;
f_containsUnacceptableEdge (`<=`, f_LE) `[1;2;3;4]`;;
f_containsDuplicateEdge tm2 `Face [1;2] Nonfinal` `1` `[1;2;3]`;;

let trie = `Tries [0] [1, Tries [1;2] []; 2, Tries [4] []]`;;
type_of trie;;
f_alist trie;;
f_values trie;;
f_lookup trie `[2]`;;
f_rem_alist `1` `[2,2;5,3;1,1;3,4]`;;
f_update trie `[1]` `[2;5]`;;

f_minimalFace `[Face [1;2] Final; Face [2;3;4] Nonfinal; Face [1] Final]`;;
f_minimalVertex tm2 `Face [1;2;3] Final`;;
f_listSum `[1;2;3]` (`SUC`, f_SUC);;
f_heightsNewVertices `1` `4` `4`;;
f_replacefacesAt `[1;2;3]` `1` `[1]` `[[2]]`;;
f_split_face `Face [1;2;3;4] Final` `2` `4` `[5;6]`;;
f_splitFace tm2 `1` `2` `Face [1;2;3] Nonfinal` `[1;2]`;;
f_makeFaceFinalFaceList `Face [1;2;3] Final` `[Face [1;2;3] Nonfinal]`;;
f_makeFaceFinal `Face [3] Nonfinal` tm;;
f_subdivFace tm2 `Face [3;2;1;0] Nonfinal` `[SOME 1; NONE; SOME 3]`;;

f_enumAppend `5` `[[1; 2; 3; 2]; [0]]`;;
f_enumerator `5` `7`;;
f_enum `5` `7`;;

f_hideDups `[1;2;3;3;3;4;3]`;;
f_indexToVertexList `Face [1;2;3] Nonfinal` `2` `[1;2;0;0]`;;
f_notame tm2;;
f_excessAtType `2` `4` `0`;;
f_excessAt tm2 `3`;;
f_faceSquanderLowerBound tm2;;
f_deleteAround tm2 `1` `[1,2; 0,3]`;;

f_excessNotAtRec `[1,2; 3,4]` tm2;;
f_excessTable tm `[0;1]`;;
f_excessNotAt tm `SOME 0`;;
f_squanderLowerBound tm2;;
f_polysizes `1` tm2;;
f_is_tame13a tm2;;
f_generatePolygonTame `1` `0` `Face [1;2] Final` tm;;
f_next_tame0 `2` tm2;;
f_is_tame tm2;;
f_next_tame `0` tm2;;
f_nof_vertices `[[1;2]; [3]; [0;1]]`;;

f_qsort (`>`, f_GT) `[1;0;3;2;4;1]`;;
f_hash `[[1;2;3]; [1]; [2;3;4]]`;;
f_fgraph tm2;;
f_merge `[1,2; 5,1]` `[3,4; 1,3]`;;
f_compat `[1,2; 5,1]` `[5,4; 1,3]`;;

f_pr_iso_test `[[1;2];[3]]` `[[2;1];[2]]`;;
f_iso_test `[[1;2];[2]]` `[[2;1];[2]]`;;

let trie = `Tries [[[0]]] [1, Tries [[[1;2]]] []; 2, Tries [[[4]]] []]`;;
f_insert_mod_trie `[[1]]` trie;;

f_tameEnumFilter;;

let const_names = 
  List.map (fun (n, th, _) ->
    let th0 = hd (BODY_CONJUNCTS th) in
    let const, _ = strip_comb (lhand (concl th0)) in
    let name, _ = dest_const const in
    name) rules;;

let () =
  set_extra_for_all db Extra_counter;
  set_rule db `(=):A->A->bool`;
  write_rules_names db "out.hl" const_names;;
loadt "out.hl";;
