loadt "default_db.hl";;

(* Original definitions are written by J. Harrison based on F. Wiedijk code *)

(* ------------------------------------------------------------------------- *)
(* Use :: as infix CONS to maintain the look and feel a bit better.          *)
(* Could also use infix @ for APPEND, but then that is the Hilbert choice.   *)
(* ------------------------------------------------------------------------- *)

unspaced_binops := insert "::" (!unspaced_binops);;
parse_as_infix ("::",(23,"right"));;
override_interface("::",`CONS`);;

(* ------------------------------------------------------------------------- *)
(* Auxiliary/library functions.                                              *)
(* ------------------------------------------------------------------------- *)

let map_of_DEF = define
 `map_of l k =
    match l with ((l, v) :: ps) ->
        (if l = k then SOME v else map_of ps k)
    | [] -> NONE`;;

let the_DEF = define
 `the (SOME x2) = x2`;;

let is_none_DEF = define
  `is_none x = match x with NONE -> T | SOME unused -> F`;;

let funpow_DEF = define
 `funpow n f =
  (if n = 0 then I
    else f o funpow (n - 1) f)`;;

let funpow_ALT = prove
  (`!n. funpow n f (x:A) = if n = 0 then x else funpow (PRE n) f (f x)`,
  INDUCT_TAC THEN ONCE_REWRITE_TAC[funpow_DEF] THEN REWRITE_TAC[I_DEF] THEN
    ASM_REWRITE_TAC[NOT_SUC; PRE; SUC_SUB1; o_DEF] THEN
    COND_CASES_TAC THEN REWRITE_TAC[ARITH_RULE `PRE n = n - 1`]);;

let nth_DEF = define
 `nth (x :: xs) n =
  (if n = 0 then x
    else nth xs (n - 1))`;;

let fold_DEF = define
 `fold f l s =
  match l with
  | (x :: xs) -> fold f xs (f x s)
  | [] -> s`;;

let rev_DEF = define
 `rev xs = fold (\a b. a :: b) xs []`;;

let upt_DEF =
  let eth = prove_general_recursive_function_exists
   `?upt. !i j. upt i j = (if i < j then i :: upt (SUC i) j else [])` in
  let th0 = ISPEC `MEASURE(\(i:num,j). j - i)`
   (REWRITE_RULE[LEFT_IMP_EXISTS_THM] (DISCH_ALL eth)) in
  let th1 = REWRITE_RULE[WF_MEASURE; MEASURE] th0 in
  let th2 = ARITH_RULE (lhand(concl th1)) in
  let def = new_specification ["upt"] (MP th1 th2) in
  prove(`upt i j = (if i < j then i :: upt (SUC i) j else [])`,
        MATCH_ACCEPT_TAC def);;

let zip_DEF = define
 `zip xs ys =
  match xs,ys with
  | (x :: xs),(y :: ys) -> (x, y) :: zip xs ys
  | xs,[] -> []
  | [],ys -> []`;;

let zip_ALT = prove
  (`zip (x :: xs) (y :: ys) = (x:A, y:B) :: zip xs ys 
      /\ zip xs ([]:(B)list) = [] 
      /\ zip ([]:(A)list) ys = []`,
  REPEAT CONJ_TAC THEN GEN_REWRITE_TAC LAND_CONV [zip_DEF] THEN 
    CONV_TAC (TOP_DEPTH_CONV MATCH_CONV) THEN REWRITE_TAC[] THEN
    COND_CASES_TAC THEN REWRITE_TAC[]);;

let null_DEF = define
 `null xs =
  match xs with
  | [] -> T
  | (x :: xs) -> F`;;

let last_DEF = define
 `last (x :: xs) = (if null xs then x else last xs)`;;

let maps_DEF = define
 `maps f xs =
  match xs with
  | [] -> []
  | (x :: xs) -> APPEND (f x) (maps f xs)`;;

let foldl_DEF = define
 `foldl f a xs =
  match xs with
  | [] -> a
  | (x :: xs) -> foldl f (f a x) xs`;;

let foldr_DEF = define
 `foldr f xs =
  match xs with
  | [] -> I
  | (x :: xs) -> f x o foldr f xs`;;

let foldr_ALT = prove
  (`foldr (f:A->B->B) [] a = a 
      /\ foldr (f:A->B->B) (x :: xs) a = f x (foldr f xs a)`,
  CONJ_TAC THENL [
    REWRITE_TAC[foldr_DEF; I_DEF];
    GEN_REWRITE_TAC (LAND_CONV o RATOR_CONV) [foldr_DEF] THEN REWRITE_TAC[o_DEF]
  ]);;

let concat_DEF = define
 `concat xss = foldr (APPEND) xss []`;;

let filter_DEF = define
 `filter p xs =
  match xs with
  | [] -> []
  | (x :: xs) -> (if p x then x :: filter p xs else filter p xs)`;;

let member_DEF = define
 `member xs y =
  match xs with
  | [] -> F
  | (x :: xs) -> (=) x y \/ member xs y`;;

let member_ALT = prove
  (`member xs (y:A) =
    match xs with
    | [] -> F
    | (x :: xs) -> if x = y then T else member xs y`,
  GEN_REWRITE_TAC LAND_CONV [member_DEF] THEN
    ASM_REWRITE_TAC[MESON[] `!x y xs. x = (y:A) \/ member xs y <=> if x = y then T else member xs y`]);;

let rotate1_DEF = define
 `rotate1 xs =
  match xs with
  | [] -> []
  | (x :: xs) -> APPEND xs [x]`;;

let rotate_DEF = define
 `rotate n = funpow n rotate1`;;

let rotate_ALT = prove
  (`rotate n l = if n = 0 then l else rotate (PRE n) (rotate1 l)`,
  REWRITE_TAC[rotate_DEF] THEN GEN_REWRITE_TAC LAND_CONV [funpow_ALT] THEN REWRITE_TAC[]);;

let rotate_ALT2 = prove
  (`rotate n l = 
      match n with
      | 0 -> l
      | n when n > 0 -> rotate (PRE n) (rotate1 l)`,
  CONV_TAC (TOP_DEPTH_CONV MATCH_CONV) THEN
    ASM_CASES_TAC `n = 0` THEN ASM_REWRITE_TAC[ARITH_RULE `n > 0 <=> ~(n = 0)`] THENL [
      REWRITE_TAC[rotate_ALT];
      GEN_REWRITE_TAC LAND_CONV [rotate_ALT] THEN ASM_REWRITE_TAC[]
    ]);;

let hd_DEF = define
 `hd (x21 :: x22) = x21`;;

let tl_DEF = define
 `tl xs =
  match xs with
  | [] -> []
  | (x21 :: x22) -> x22`;;

let list_ex_DEF = define
 `list_ex p xs =
  match xs with
  | [] -> F
  | (x :: xs) -> p x \/ list_ex p xs`;;

let list_ex_ALT = prove
  (`list_ex p xs =
      match xs with
      | [] -> F
      | ((x:A) :: xs) -> if p x then T else list_ex p xs`,
  GEN_REWRITE_TAC LAND_CONV [list_ex_DEF] THEN
    ASM_REWRITE_TAC[MESON[] `!p (x:A) xs. p x \/ list_ex p xs <=> if p x then T else list_ex p xs`]);;
  
let remdups_DEF = define
 `remdups xs =
  match xs with
  | [] -> []
  | (x :: xs) ->
    (if member xs x then remdups xs else x :: remdups xs)`;;

let remove1_DEF = define
 `remove1 x xs =
  match xs with
  | [] -> []
  | (y :: xs) ->
    (if x = y then xs else y :: remove1 x xs)`;;

let map_DEF = define
 `map fi xs =
  match xs with
  | [] -> []
  | (x21a :: x22) -> fi x21a :: map fi x22`;;

let pred_list_DEF = define
 `pred_list p xs =
  match xs with
  | [] -> T
  | (x :: xs) -> p x /\ pred_list p xs`;;

let pred_list_ALT = prove
  (`pred_list p xs =
      match xs with
      | [] -> T
      | ((x:A) :: xs) -> if p x then pred_list p xs else F`,
  GEN_REWRITE_TAC LAND_CONV [pred_list_DEF] THEN
    ASM_REWRITE_TAC[MESON[] `!p (x:A) xs. p x /\ pred_list p xs <=> if p x then pred_list p xs else F`]);;

let replicate_DEF = define
 `replicate n x =
  (if n = 0 then []
    else x :: replicate (n - 1) x)`;;

let gen_length_DEF = define
 `gen_length n xs =
  match xs with
  | (x :: xs) -> gen_length (SUC n) xs
  | [] -> n`;;

let map_filter_DEF = define
 `map_filter f xs =
  match xs with
  | [] -> []
  | (x :: xs) ->
    (match f x with NONE -> map_filter f xs
                  | SOME y -> y :: map_filter f xs)`;;

let map_filter_ALT = (PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] o prove)
  (`map_filter (f:A->(B)option) xs =
    match xs with
    | [] -> []
    | (x :: xs) ->
      let r = f x in
        if is_none r then map_filter f xs 
        else the r :: map_filter f xs`,
  GEN_REWRITE_TAC LAND_CONV [map_filter_DEF] THEN
    DISJ_CASES_TAC (SPEC `xs:(A)list` list_CASES) THEN ASM_REWRITE_TAC[] THEN
    POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN
    DISJ_CASES_TAC (ISPEC `r:(B)option` (cases "option")) THEN ASM_REWRITE_TAC[is_none_DEF] THEN
    POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[the_DEF]);;

let list_update_DEF = define
 `list_update xs i y =
  match xs with
  | [] -> []
  | (x :: xs) ->
    (if i = 0 then y :: xs
      else x :: list_update xs (i - 1) y)`;;

let all_interval_nat_DEF =
  let eth = prove_general_recursive_function_exists
   `?all_interval_nat. !p i j.
        all_interval_nat p i j <=>
        if j <= i then T else p i /\ all_interval_nat p (SUC i) j` in
  let th0 = ISPEC `MEASURE(\((P:num->bool),i:num,j). j - i)`
   (REWRITE_RULE[LEFT_IMP_EXISTS_THM] (DISCH_ALL eth)) in
  let th1 = REWRITE_RULE[WF_MEASURE; MEASURE] th0 in
  let th2 = ARITH_RULE (lhand(concl th1)) in
  let def = new_specification ["all_interval_nat"] (MP th1 th2) in
  prove(`all_interval_nat p i j <=>
         j <= i \/ p i /\ all_interval_nat p (SUC i) j`,
        GEN_REWRITE_TAC LAND_CONV [def] THEN MESON_TAC[]);;

let all_interval_nat_ALT = prove
  (`all_interval_nat p i j = 
      if j <= i then T
      else if p i then all_interval_nat p (SUC i) j 
      else F`,
  GEN_REWRITE_TAC LAND_CONV [all_interval_nat_DEF] THEN MESON_TAC[]);;

let size_list_DEF = define
 `size_list x = gen_length 0 x`;;

let fst_DEF = define
 `fst (x1, x2) = x1`;;

let snd_DEF = define
  `snd (x1, x2) = x2`;;

let mapAt_DEF = define
 `mapAt ns f asa =
  match ns with
  | [] -> asa
  | (n :: ns) ->
    (if n < size_list asa
      then mapAt ns f (list_update asa n (f (nth asa n)))
      else mapAt ns f asa)`;;

let splitAtRec_DEF = define
 `splitAtRec c bs asa =
  match asa with
  | [] -> (bs, [])
  | (a :: asa) ->
    if a = c then (bs, asa) else splitAtRec c (APPEND bs [a]) asa`;;

let splitAt_DEF = define
 `splitAt c asa = splitAtRec c [] asa`;;

let between_DEF = define
 `between vs (ram_1:A) ram_2 =
  let
    (pre_1, post_1) = splitAt ram_1 vs
  in
    (if member post_1 ram_2
      then let
             (pre_2, unused) = splitAt ram_2 post_1
           in
             pre_2
      else let
             (pre_2, unused) = splitAt ram_2 pre_1
           in
             APPEND post_1 pre_2)`;;

let between_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] between_DEF;;

let minimall_DEF = define
 `minimall m (x :: xs) =
  (if null xs then x
    else let
           mxs = minimall m xs
         in
           (if (m x) <= (m mxs) then x else mxs))`;;

let minimall_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] minimall_DEF;;

let replace_DEF = define
 `replace x ys zs =
  match zs with
  | [] -> []
  | (z :: zs) ->
    (if z = x then APPEND ys zs else z :: replace x ys zs)`;;

let removeKey_DEF = define
 `removeKey a ps =
  filter (\p. ~(a = fst p)) ps`;;

let removeKeyList_DEF = define
 `removeKeyList ws ps =
  match ws with
  | [] -> ps
  | (w :: ws) -> removeKey w (removeKeyList ws ps)`;;




let facetype_INDUCT,facetype_RECURSION = define_type
  "facetype = Final | Nonfinal";;

let face_INDUCT,face_RECURSION = define_type
 "face = Face (num list) facetype";;

let graph_INDUCT,graph_RECURSION = define_type
 "graph = Graph (face list) num ((face list) list) (num list)";;

let vertices_face_DEF = define
 `vertices_face (Face vs f) = vs`;;

let final_face_DEF = define
 `final_face x =
  match x with
  | (Face vs Nonfinal) -> F
  | (Face vs Final) -> T`;;

let faceListAt_DEF = define
 `faceListAt (Graph fs n f h) = f`;;

let facesAt_DEF = define
 `facesAt g v = nth (faceListAt g) v`;;

let tri_DEF = define
 `tri g v =
  size_list (filter (\f. final_face f /\ size_list (vertices_face f) = 3)
            (facesAt g v))`;;

let tri_ALT = ONCE_REWRITE_RULE[MESON[] `!P Q. P /\ Q <=> if P then Q else F`] tri_DEF;;

let quad_DEF = define
 `quad g v =
   size_list (filter (\f. final_face f /\ size_list (vertices_face f) = 4)
             (facesAt g v))`;;

let quad_ALT = ONCE_REWRITE_RULE[MESON[] `!P Q. P /\ Q <=> if P then Q else F`] quad_DEF;;

let faces_DEF = define
 `faces (Graph fs n f h) = fs`;;

let graph_DEF = define
 `graph n =
  let
    vs = upt 0 n
  in let
    fs = [Face vs Final; Face (rev vs) Nonfinal]
  in
    Graph fs n (replicate n fs) (replicate n 0)`;;

let graph_ALT = CONV_RULE (TOP_DEPTH_CONV let_CONV) graph_DEF;;
let graph_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] graph_DEF;;

let degree_DEF = define
 `degree g v = size_list (facesAt g v)`;;

let except_DEF = define
 `except g v =
    size_list
    (filter (\f. final_face f /\ 5 <= size_list (vertices_face f))
    (facesAt g v))`;;

let except_ALT = ONCE_REWRITE_RULE[MESON[] `!P Q. P /\ Q <=> if P then Q else F`] except_DEF;;

let finals_DEF = define
 `finals g = filter final_face (faces g)`;;

let heights_DEF = define
 `heights (Graph fs n f h) = h`;;

let height_DEF = define
 `height g v = nth (heights g) v`;;

let nextElem_DEF = define
 `nextElem asa b x =
  match asa with
  | [] -> b
  | (a :: asa) ->
    (if x = a then (match asa with [] -> b | aa :: _ -> aa)
      else nextElem asa b x)`;;

let nextElem_ALT = prove
  (`nextElem [] b (x:A) = b
      /\ nextElem [a] b x = b
      /\ nextElem (a :: aa :: asa) b x = if x = a then aa else nextElem (aa :: asa) b x`,
  REPEAT CONJ_TAC THEN GEN_REWRITE_TAC LAND_CONV [nextElem_DEF] THEN REWRITE_TAC[] THEN
    REWRITE_TAC[nextElem_DEF; COND_ID]);;

let setFinal_DEF = define
 `setFinal f = Face (vertices_face f) Final`;;

let nextVertex_DEF = define
 `nextVertex f =
  let
    vs = vertices_face f
  in
    nextElem vs (hd vs)`;;

let nextVertex_ALT = (PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] o prove)
  (`nextVertex f n =
    let vs = vertices_face f in
      nextElem vs (hd vs) n`,
  REWRITE_TAC[nextVertex_DEF; LET_DEF; LET_END_DEF]);;

let neighbors_DEF = define
 `neighbors g v = map (\f. nextVertex f v) (facesAt g v)`;;

let nonFinals_DEF = define
 `nonFinals g = filter (\f. ~ (final_face f)) (faces g)`;;

let vertextype_DEF = define
 `vertextype g v = (tri g v, (quad g v, except g v))`;;

let finalVertex_DEF = define
 `finalVertex g v = pred_list final_face (facesAt g v)`;;

let final_graph_DEF = define
 `final_graph g = null (nonFinals g)`;;

let nextVertices_DEF = define
 `nextVertices f n v = funpow n (nextVertex f) v`;;

let countVertices_DEF = define
 `countVertices (Graph fs n f h) = n`;;

let directedLength_DEF = define
 `directedLength f a b =
     (if a = b then 0 else size_list (between (vertices_face f) a b) + 1)`;;

let vertices_graph_DEF = define
 `vertices_graph (Graph fs n f h) = upt 0 n`;;

 let tame10_DEF = define
 `tame10 g <=> (let n = countVertices g in 13 <= n /\ n <= 15)`;;

let tame10_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] tame10_DEF;;

let tame11a_DEF = define
 `tame11a g <=> pred_list (\v. 3 <= degree g v) (vertices_graph g)`;;

let tame11b_DEF = define
`tame11b g <=>
  pred_list (\v. degree g v <= (if except g v = 0 then 7 else 6))
  (vertices_graph g)`;;

let tame12o_DEF = define
`tame12o g <=>
  pred_list
  (\v. if ~(except g v = 0) /\ degree g v = 6
       then vertextype g v = 5,0,1
       else T)
  (vertices_graph g)`;;

let tame10ub_DEF = define
`tame10ub g <=> countVertices g <= 15`;;

let excessTCount_DEF = define
`excessTCount = 6300`;;

let squanderTarget_DEF = define
`squanderTarget = 15410`;;

let squanderFace_DEF = define
`squanderFace n =
  (if n = 3
   then 0
   else if n = 4
        then 2060
        else if n = 5 then 4819
             else if n = 6 then 7578 else squanderTarget)`;;

let squanderFace_ALT = REWRITE_RULE[squanderTarget_DEF] squanderFace_DEF;;

let squanderVertex_DEF = define
`squanderVertex p q =
   (if p = 0 /\ q = 3 then 6180
    else if p = 0 /\ q = 4 then 9700
    else if p = 1 /\ q = 2 then 6560
    else if p = 1 /\ q = 3 then 6180
    else if p = 2 /\ q = 1 then 7970
    else if p = 2 /\ q = 2 then 4120
    else if p = 2 /\ q = 3 then 12851
    else if p = 3 /\ q = 1 then 3110
    else if p = 3 /\ q = 2 then 8170
    else if p = 4 /\ q = 0 then 3470
    else if p = 4 /\ q = 1 then 3660
    else if p = 5 /\ q = 0 then 400
    else if p = 5 /\ q = 1 then 11360
    else if p = 6 /\ q = 0 then 6860
    else if p = 7 /\ q = 0 then 14500
    else squanderTarget)`;;

let squanderVertex_ALT = REWRITE_RULE[squanderTarget_DEF] squanderVertex_DEF;;

let squanderVertex_ALT2 = prove
  (`squanderVertex 0 3 = 6180
    /\ squanderVertex 0 4 = 9700
    /\ squanderVertex 1 2 = 6560
    /\ squanderVertex 1 3 = 6180
    /\ squanderVertex 2 1 = 7970
    /\ squanderVertex 2 2 = 4120
    /\ squanderVertex 2 3 = 12851
    /\ squanderVertex 3 1 = 3110
    /\ squanderVertex 3 2 = 8170
    /\ squanderVertex 4 0 = 3470
    /\ squanderVertex 4 1 = 3660
    /\ squanderVertex 5 0 = 400
    /\ squanderVertex 5 1 = 11360
    /\ squanderVertex 6 0 = 6860
    /\ squanderVertex 7 0 = 14500
    /\ (~(member [0,3; 0,4; 1,2; 1,3; 2,1; 2,2; 2,3; 3,1; 3,2; 4,0; 4,1; 5,0; 5,1; 6,0; 7,0] (p,q))
        ==> squanderVertex p q = squanderTarget)`,
  REWRITE_TAC[squanderVertex_DEF; member_DEF; PAIR_EQ; ARITH_EQ] THEN
    REPEAT COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN ARITH_TAC);;

let maxGon_DEF = define
`maxGon p = p + 3`;;

let seed_DEF = define
`seed p = graph (maxGon p)`;;

let duplicateEdge_DEF = define
`duplicateEdge g f a b <=>
  2 <= directedLength f a b /\
  2 <= directedLength f b a /\
  member (neighbors g a) b`;;

let containsUnacceptableEdgeSnd_DEF = define
`containsUnacceptableEdgeSnd n v ws <=>
  (match ws with
     [] -> F
   | w::ws -> (match ws with
                 [] -> F
               | wa :: _ -> (if v < w /\ w < wa /\ n w wa
                           then T
                           else containsUnacceptableEdgeSnd n w ws)))`;;

let containsUnacceptableEdgeSnd_ALT = prove
  (`containsUnacceptableEdgeSnd n v [] = F
      /\ containsUnacceptableEdgeSnd n v [w] = F
      /\ containsUnacceptableEdgeSnd n v (w :: wa :: ws) =
          if v < w /\ w < wa /\ n w wa then T
            else containsUnacceptableEdgeSnd n w (wa :: ws)`,
  REPEAT CONJ_TAC THEN GEN_REWRITE_TAC LAND_CONV [containsUnacceptableEdgeSnd_DEF] THEN 
    REWRITE_TAC[]);;

let containsUnacceptableEdge_DEF = define
`containsUnacceptableEdge n vs <=>
  (match vs with
     [] -> F
   | v::vs -> (match vs with
                 [] -> F
               | w :: _ -> (if v < w /\ n v w
                          then T
                          else containsUnacceptableEdgeSnd n v vs)))`;;

let containsUnacceptableEdge_ALT = prove
  (`containsUnacceptableEdge n [] = F
      /\ containsUnacceptableEdge n [v] = F
      /\ containsUnacceptableEdge n (v :: w :: vs) =
          if v < w /\ n v w then T
            else containsUnacceptableEdgeSnd n v (w :: vs)`,
  REPEAT CONJ_TAC THEN GEN_REWRITE_TAC LAND_CONV [containsUnacceptableEdge_DEF] THEN 
    REWRITE_TAC[]);;

let containsDuplicateEdge_DEF = define
  `containsDuplicateEdge g f v is =
   containsUnacceptableEdge (\i j.
      duplicateEdge g f (nextVertices f i v) (nextVertices f j v))
    is`;;


let tries_INDUCT,tries_RECURSION = define_type
 "tries = Tries (B list) ((A # tries) list)";;

let alist_DEF = define
 `alist (Tries vs al) = al`;;

let values_DEF = define
 `values (Tries vs al) = vs`;;

let lookup_DEF = define
 `lookup t asa =
  match asa with
  | [] -> values t
  | (a :: asa) ->
    (match map_of (alist t) a with NONE -> []
      | SOME at -> lookup at asa)`;;

let lookup_ALT = (PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] o prove)
  (`lookup (t:(A,B)tries) asa =
    match asa with
    | [] -> values t
    | (a :: asa) ->
        let r = map_of (alist t) a in
        if is_none r then [] else lookup (the r) asa`,
  GEN_REWRITE_TAC LAND_CONV [lookup_DEF] THEN
    DISJ_CASES_TAC (SPEC `asa:(A)list` list_CASES) THEN ASM_REWRITE_TAC[] THEN
    POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN LET_TAC THEN
    DISJ_CASES_TAC (ISPEC `r:((A,B)tries)option` (cases "option")) THEN ASM_REWRITE_TAC[is_none_DEF] THEN
    POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[the_DEF]);;

let rem_alist_DEF = define
  `rem_alist k ps =
   (match ps with
      [] -> []
    | p::ps -> (if fst p = k then ps else p::rem_alist k ps))`;;

let update_DEF = define
 `update t asa vs =
  match asa with
  | [] -> Tries vs (alist t)
  | (a :: asa) ->
    let
      tt =
        (match map_of (alist t) a with NONE -> Tries [] []
          | SOME at -> at)
    in
      Tries (values t) ((a, update tt asa vs) :: rem_alist a (alist t))`;;

let update_ALT = (PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] o prove)
  (`update (t:(A,B)tries) asa vs =
    match asa with
    | [] -> Tries vs (alist t)
    | (a :: asa) ->
      let tt =
        let r = map_of (alist t) a in
        if is_none r then Tries [] [] else the r 
      in
      Tries (values t) ((a, update tt asa vs) :: rem_alist a (alist t))`,
  GEN_REWRITE_TAC LAND_CONV [update_DEF] THEN
    DISJ_CASES_TAC (SPEC `asa:(A)list` list_CASES) THEN ASM_REWRITE_TAC[] THEN
    POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN REPEAT LET_TAC THEN
    REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REPEAT (POP_ASSUM (fun th -> REWRITE_TAC[SYM th])) THEN LET_TAC THEN
    DISJ_CASES_TAC (ISPEC `r:((A,B)tries)option` (cases "option")) THEN ASM_REWRITE_TAC[is_none_DEF] THEN
    POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[the_DEF]);;


(* let vector_vector_INDUCT,vector_vector_RECURSION = define_type
 "vector_vector = Array num (num->A)";;

let vector_sub_DEF = define
 `vector_sub (Array n f) n = f n`;;

let vector_tabulate_DEF = define
 `vector_tabulate n f = Array n f`;;

let sub_DEF = define
 `sub asa n = vector_sub asa n`;;

let of_fun_DEF = define
 `of_fun f n = vector_tabulate n f`;; *)

let minimalFace_DEF = define
 `minimalFace fs = minimall (size_list o vertices_face) fs`;;

let minimalFace_ALT = REWRITE_RULE[o_DEF] minimalFace_DEF;;

let minimalVertex_DEF = define
 `minimalVertex g f =
   minimall (height g) (vertices_face f)`;;

let listSum_DEF = define
 `listSum ls f =
  match ls with
  | [] -> 0
  | (l :: ls) -> f l + listSum ls f`;;

let heightsNewVertices_DEF = define
 `heightsNewVertices h_1 h_2 n =
   map (\i. MIN ((h_1 + i) + 1) ((h_2 + n) - i)) (upt 0 n)`;;

let replacefacesAt_DEF = define
 `replacefacesAt ns fa fs f =
  mapAt ns (replace fa fs) f`;;

let split_face_DEF = define
 `split_face f ram_1 ram_2 newVs =
   (let vs = vertices_face f in
    let f_1 = APPEND [ram_1] (APPEND (between vs ram_1 ram_2) [ram_2]) in
    let f_2 = APPEND [ram_2] (APPEND (between vs ram_2 ram_1) [ram_1]) in
    Face (APPEND (rev newVs) f_1) Nonfinal,Face (APPEND f_2 newVs) Nonfinal)`;;

let split_face_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] split_face_DEF;;

let splitFace_DEF = define
 `splitFace g ram_1 ram_2 oldF newVs =
  let fs = faces g in 
  let n = countVertices g in 
  let fsa = faceListAt g in 
  let h = heights g in 
  let vs_1 = between (vertices_face oldF) ram_1 ram_2 in 
  let vs_2 = between (vertices_face oldF) ram_2 ram_1 in 
  let (f_1, f_2) = split_face oldF ram_1 ram_2 newVs in 
  let fsaa = replacefacesAt vs_1 oldF [f_1] fsa in 
  let fsab = replacefacesAt vs_2 oldF [f_2] fsaa in 
  let fsac = replacefacesAt [ram_1] oldF [f_2; f_1] fsab in 
  let fsad = replacefacesAt [ram_2] oldF [f_1; f_2] fsac in 
  let fsae = APPEND fsad (replicate (size_list newVs) [f_1; f_2]) in
    (f_1, (f_2, Graph
                  (APPEND (replace oldF [f_2] fs) [f_1])
                  (n + size_list newVs)
                  fsae
                  (APPEND h (heightsNewVertices (nth h ram_1) (nth h ram_2)
                                  (size_list newVs)))))`;;

let splitFace_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] splitFace_DEF;;

let makeFaceFinalFaceList_DEF = define
 `makeFaceFinalFaceList f fs =
    replace f [setFinal f] fs`;;

let makeFaceFinal_DEF = define
 `makeFaceFinal f g =
  Graph
    (makeFaceFinalFaceList f (faces g))
    (countVertices g)
    (map (makeFaceFinalFaceList f) (faceListAt g))
    (heights g)`;;


let LET_ELIM_THM = prove
 (`(!P e. (let x = e in P x) = P e) /\
   (!P e. (let x,y = e in P x y) = P (FST e) (SND e)) /\
   (!P e. (let x,y,z = e in P x y z) = P (FST e) (FST(SND e)) (SND(SND e)))`,
  REWRITE_TAC[FORALL_PAIR_THM; LET_DEF; LET_END_DEF]);;


let subdivFacea_DEF =
  let tm =
   `subdivFacea g f u n vos =
      match vos with
      | [] -> makeFaceFinal f g
      | (vo :: vos) ->
        (match vo with NONE -> subdivFacea g f u (SUC n) vos
          | SOME v ->
            (if (=) (nextVertex f u) v /\
                  (=) n 0
              then subdivFacea g f v 0 vos
              else let
                     ws =
                       upt (countVertices g)
                         ((+) (countVertices g) n)
                   in let
                     (_, (f_2, ga)) = splitFace g u v f ws
                   in
                     subdivFacea ga f_2 v 0 vos))` in
  let th = REWRITE_CONV[LET_ELIM_THM] tm in
  let tm' = rand(concl th) in
  let def = define tm' in
  REWRITE_RULE[GSYM th] def;;

let subdivFacea_ALT = (PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] o prove)
  (`subdivFacea g f u n [] = makeFaceFinal f g
    /\ subdivFacea g f u n (NONE :: vos) = subdivFacea g f u (SUC n) vos
    /\ subdivFacea g f u n (SOME v :: vos) =
        if nextVertex f u = v /\ n = 0 then subdivFacea g f v 0 vos
        else
          let ws = upt (countVertices g) (countVertices g + n) in
          let (unused, (f_2, ga)) = splitFace g u v f ws in
            subdivFacea ga f_2 v 0 vos`,
  REPEAT CONJ_TAC THEN GEN_REWRITE_TAC LAND_CONV [subdivFacea_DEF] THEN REWRITE_TAC[]);;

let subdivFace_DEF = define
 `subdivFace g f vos =
  subdivFacea g f (the (hd vos)) 0 (tl vos)`;;



let vector_vector_INDUCT,vector_vector_RECURSION = define_type
 "vector_vector = Array num (num->A)";;

let vector_sub_DEF = define
 `vector_sub (Array n f) m = f m`;;

let vector_tabulate_DEF = define
 `vector_tabulate n f = Array n f`;;

let sub_DEF = define
 `sub asa n = vector_sub asa n`;;

let of_fun_DEF = define
 `of_fun f n = vector_tabulate n f`;;

let tabulate2_DEF = define
 `tabulate2 m n f = of_fun (\i. of_fun (f i) n) m`;;


let enumAppend_DEF = define
 `enumAppend nmax iss =
  maps
    (\is.
      map (\n. APPEND is [n]) (upt (last is) (SUC nmax)))
    iss`;;

let enumBase_DEF = define
 `enumBase nmax =
  map (\i. [i]) (upt 0 (SUC nmax))`;;

let enumerator_DEF = define
  `enumerator inner outer =
   (let nmax = outer - 2 in
    let k = inner - 3 in
    map (\is. APPEND [0] (APPEND is [outer - 1]))
    (funpow k (enumAppend nmax) (enumBase nmax)))`;;

let enumerator_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] enumerator_DEF;;

let enumTab_DEF = define
 `enumTab = tabulate2 9 9 enumerator`;;

let enum_DEF = define
 `enum inner outer =
     (if inner < 9 /\ outer < 9
      then sub (sub enumTab inner) outer
      else enumerator inner outer)`;;

let enum_ALT = prove
  (`enum inner outer = enumerator inner outer`,
  REWRITE_TAC[enum_DEF] THEN
    SUBGOAL_THEN `sub (sub enumTab inner) outer = enumerator inner outer` (fun th -> REWRITE_TAC[th; COND_ID]) THEN
    REWRITE_TAC[enumTab_DEF; tabulate2_DEF; of_fun_DEF; vector_tabulate_DEF; sub_DEF; vector_sub_DEF]);;

let hideDupsRec_DEF = define
 `hideDupsRec a bs =
  match bs with
  | [] -> []
  | (b :: bs) ->
    (if (=) a b then NONE :: hideDupsRec b bs
      else SOME b :: hideDupsRec b bs)`;;

let hideDups_DEF = define
 `hideDups bs =
  match bs with
  | [] -> []
  | (b :: bs) -> SOME b :: hideDupsRec b bs`;;

let indexToVertexList_DEF = define
 `indexToVertexList f v is =
  hideDups (map (\k. nextVertices f k v) is)`;;

let notame_DEF = define
 `notame g <=> ~ (tame10ub g /\ tame11b g)`;;

let d4_const_DEF = define
 `d4_const : num =
  squanderFace ( ( 4))`;;

let d3_const_DEF = define
 `d3_const : num =
  squanderFace ( ( 3))`;;

let excessAtType_DEF = define
 `excessAtType t q e =
     (if e = 0
      then if 7 < t + q
           then squanderTarget
           else squanderVertex t q - t * d3_const - q * d4_const
      else if ~((t + q) + e = 6)
           then 0
           else if t = 5 then excessTCount else squanderTarget)`;;

let excessAtType_ALT = 
  REWRITE_RULE [d3_const_DEF; d4_const_DEF; squanderTarget_DEF; 
    squanderFace_DEF; MULT_0; SUB_0; ARITH; excessTCount_DEF]
  excessAtType_DEF;;

let excessAt_DEF = define
 `excessAt g v =
  (if ~ (finalVertex g v) then 0
    else excessAtType (tri g v) (quad g v) (except g v))`;;

let faceSquanderLowerBound_DEF = define
 `faceSquanderLowerBound g =
  listSum (finals g)
    (\f. squanderFace (size_list (vertices_face f)))`;;

let deleteAround_DEF = define
 `deleteAround g v ps =
   (let vs =
        (\f. let n = nextVertex f v in
             if size_list (vertices_face f) = 4
             then [n; nextVertex f n]
             else [n]) in
    removeKeyList (maps vs (facesAt g v)) ps)`;;

let deleteAround_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] deleteAround_DEF;;

let LENGTH_FILTER = prove
 (`!p l. LENGTH(filter p l) <= LENGTH l`,
  GEN_TAC THEN LIST_INDUCT_TAC THEN ONCE_REWRITE_TAC[filter_DEF] THEN
  REWRITE_TAC[] THEN
  REPEAT COND_CASES_TAC THEN REWRITE_TAC[LENGTH] THEN ASM_ARITH_TAC);;

let LENGTH_REMOVEKEY = prove
 (`!a ps. LENGTH(removeKey a ps) <= LENGTH ps`,
  REWRITE_TAC[removeKey_DEF; LENGTH_FILTER]);;

let LENGTH_REMOVEKEYLIST = prove
 (`!ws ps. LENGTH(removeKeyList ws ps) <= LENGTH ps`,
  LIST_INDUCT_TAC THEN ONCE_REWRITE_TAC[removeKeyList_DEF] THEN
  REWRITE_TAC[LE_REFL] THEN ASM_MESON_TAC[LENGTH_REMOVEKEY; LE_TRANS]);;

let LENGTH_DELETEAROUND = prove
 (`!g v ps. LENGTH(deleteAround g v ps) <= LENGTH ps`,
  REWRITE_TAC[deleteAround_DEF; LET_DEF; LET_END_DEF; LENGTH_REMOVEKEYLIST]);;

let excessNotAtRec_DEF =
  let eth = prove_general_recursive_function_exists
   `?excessNotAtRec. !ps.
     excessNotAtRec ps =
    match ps with
    | [] -> (\_ . 0)
    | ((x, y) :: ps) ->
      (\g.
        MAX (excessNotAtRec ps g)
            ((+) y (excessNotAtRec (deleteAround g x ps) g)))` in
  let th0 = ISPEC `MEASURE(\l:(num#num)list. LENGTH l)`
   (REWRITE_RULE[LEFT_IMP_EXISTS_THM] (DISCH_ALL eth)) in
  let th1 = REWRITE_RULE[WF_MEASURE; MEASURE; admissible] th0 in
  let th2 =
   prove(lhand(concl th1),
         REWRITE_TAC[FORALL_PAIR_THM; FUN_EQ_THM] THEN
         REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[IMP_CONJ] THEN
         DISCH_THEN(CONJUNCTS_THEN(ASSUME_TAC o GSYM)) THEN
         ASM_REWRITE_TAC[CONS_11; LENGTH] THEN
         SIMP_TAC[LENGTH; ARITH_RULE `n < SUC n`] THEN
         REWRITE_TAC[LT_SUC_LE] THEN ASM_MESON_TAC[LENGTH_DELETEAROUND]) in
  let def = new_specification ["excessNotAtRec"] (MP th1 th2) in
  SPEC_ALL def;;

let excessNotAtRec_ALT = prove
  (`excessNotAtRec [] unused = 0
    /\ excessNotAtRec ((x, y) :: ps) g =
        MAX (excessNotAtRec ps g) (y + excessNotAtRec (deleteAround g x ps) g)`,
  CONJ_TAC THEN GEN_REWRITE_TAC (LAND_CONV o RATOR_CONV) [excessNotAtRec_DEF] THEN REWRITE_TAC[]);;

let excessTable_DEF = define
 `excessTable g =
  map_filter
    (\v.
      let
        e = excessAt g v
      in
        (if (<) 0 e then SOME (v, e) else NONE))`;;

let excessTable_ALT = (PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] o prove)
  (`excessTable g vs = 
      map_filter (\v. let e = excessAt g v in if 0 < e then SOME (v, e) else NONE) vs`,
  REWRITE_TAC[excessTable_DEF]);;

let excessNotAt_DEF = define
 `excessNotAt g v_opt =
  let
    ps = excessTable g (vertices_graph g)
  in
    (match v_opt with NONE -> excessNotAtRec ps g
      | SOME v -> excessNotAtRec (deleteAround g v ps) g)`;;

let excessNotAt_ALT = prove
  (`excessNotAt g NONE = 
      excessNotAtRec (excessTable g (vertices_graph g)) g
    /\ excessNotAt g (SOME v) = 
        excessNotAtRec (deleteAround g v (excessTable g (vertices_graph g))) g`,
  REWRITE_TAC[excessNotAt_DEF; LET_DEF; LET_END_DEF]);;

let squanderLowerBound_DEF = define
 `squanderLowerBound g =
  (+) (faceSquanderLowerBound g) (excessNotAt g NONE)`;;

let polysizes_DEF = define
 `polysizes p g =
     (let lb = squanderLowerBound g in
      filter (\n. lb + squanderFace n < squanderTarget)
      (upt 3 (SUC (maxGon p))))`;;

let polysizes_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF; squanderTarget_DEF] polysizes_DEF;;

let is_tame13a_DEF = define
 `is_tame13a g = (<) (squanderLowerBound g) squanderTarget`;;

let is_tame13a_ALT = REWRITE_RULE[squanderTarget_DEF] is_tame13a_DEF;;

let generatePolygonTame_DEF = define
 `generatePolygonTame n v f g =
    (let enumeration = enum n (size_list (vertices_face f)) in
      let enumerationa =
          filter (\is. ~containsDuplicateEdge g f v is) enumeration in
      let vertexLists = map (indexToVertexList f v) enumerationa in
      filter (\ga. ~notame ga) (map (subdivFace g f) vertexLists))`;;

let generatePolygonTame_ALT =
  REWRITE_RULE[LET_DEF; LET_END_DEF] generatePolygonTame_DEF;;

let next_tame0_DEF = define
 `next_tame0 p g =
  let
    fs = nonFinals g
  in
    (if null fs then []
      else let
             f = minimalFace fs
           in let
             v = minimalVertex g f
           in
             maps (\i. generatePolygonTame i v f g) (polysizes p g))`;;

let next_tame0_ALT = (PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] o prove)
  (`next_tame0 p g =
      let fs = nonFinals g in
      if null fs then []
      else
        let f = minimalFace fs in
        maps (\i. generatePolygonTame i (minimalVertex g f) f g) (polysizes p g)`,
  REWRITE_TAC[next_tame0_DEF; LET_DEF; LET_END_DEF]);;

let is_tame_DEF = define
 `is_tame g <=>
  tame10 g /\
    (tame11a g /\ (tame12o g /\ is_tame13a g))`;;

let next_tame_DEF = define
 `next_tame p =
  filter (\g. ~ (final_graph g) \/ is_tame g) o
    next_tame0 p`;;

let next_tame_ALT = prove
  (`next_tame p g = filter (\g. ~(final_graph g) \/ is_tame g) (next_tame0 p g)`,
  REWRITE_TAC[next_tame_DEF; o_DEF]);;

let worklist_tree_aux_DEF = define
 `worklist_tree_aux succs f (ws, s) =
  (match ws with [] -> SOME ([]:real list, s)
    | x :: wsa -> worklist_tree_aux succs f (APPEND (succs x) wsa, f x s))`;;

let worklist_tree_DEF = define
 `(worklist_tree:(A -> A list) -> (A -> B -> B) -> A list -> B -> B option)
  succs f ws s =
  (match worklist_tree_aux succs f (ws, s) with NONE -> NONE
    | SOME (_ :real list, a) -> SOME a)`;;

let worklist_tree_ALT = (PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] o prove)
  (`worklist_tree succs (f:A->B->B) ws s =
      let aux = worklist_tree_aux succs f (ws, s) in
      if is_none aux then NONE
      else 
        SOME (snd (the aux))`,
  LET_TAC THEN ASM_REWRITE_TAC[worklist_tree_DEF] THEN
    DISJ_CASES_TAC (ISPEC `aux:((real)list#B)option` (cases "option")) THEN ASM_REWRITE_TAC[is_none_DEF] THEN
    POP_ASSUM STRIP_ASSUME_TAC THEN ASM_REWRITE_TAC[] THEN
    STRIP_ASSUME_TAC (ISPEC `a:(real)list#B` PAIR_SURJECTIVE) THEN
    ASM_REWRITE_TAC[snd_DEF; the_DEF]);;

let nof_vertices_DEF = define
 `nof_vertices = size_list o remdups o concat`;;

let nof_vertices_ALT = prove
  (`nof_vertices ns = size_list (remdups (concat ns))`,
  REWRITE_TAC[nof_vertices_DEF; o_DEF]);;


let qsort_DEF =
  let eth = prove_general_recursive_function_exists
   `?qsort. !le:(A->A->bool) xs.
        qsort le xs =
         match xs with
         | [] -> []
         | (x :: xs) ->
           APPEND (qsort le (filter (\y. ~ (le x y)) xs))
           (APPEND [x] (qsort le (filter (le x) xs)))` in
  let th1 = REWRITE_RULE[LEFT_IMP_EXISTS_THM] (DISCH_ALL eth) in
  let th2 = SPEC `MEASURE(\((le:A->A->bool),(xs:A list)). LENGTH xs)` th1 in
  let th3 = prove(lhand(concl th2),
                  REWRITE_TAC[WF_MEASURE; MEASURE] THEN
                  REPEAT STRIP_TAC THEN
                  FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN
                  REWRITE_TAC[LENGTH; LT_SUC_LE; LENGTH_FILTER]) in
  let def = new_specification ["qsort"] (MP th2 th3) in
  SPEC_ALL def;;

let hash_DEF = define
 `hash fs =
  let n = nof_vertices fs in
    APPEND [n; size_list fs]
      (qsort (\x y. y < x)
        (map
          (\i.
            foldl (+) 0
              (map_filter
                (\t. if member t i then SOME (size_list t) else NONE)
                fs))
          (upt 0 n)))`;;

let hash_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] hash_DEF;;

let fgraph_DEF = define
 `fgraph g = map vertices_face (faces g)`;;

let merge_DEF = define
 `merge xys i =
  match xys with
  | [] -> i
  | (xy :: xys) ->
    let (x, _) = xy in
      (if pred_list (\(xa, _). ~ ((=) x xa)) i
        then xy :: merge xys i else merge xys i)`;;

let merge_ALT = prove
  (`merge [] (i:(A#B)list) = i
    /\ merge ((x, y) :: xys) i = 
        if pred_list (\(xa, unused). ~(x = xa)) i then
          (x, y) :: merge xys i
        else
          merge xys i`,
  CONJ_TAC THEN GEN_REWRITE_TAC LAND_CONV [merge_DEF] THEN REWRITE_TAC[] THEN
    REWRITE_TAC[LET_DEF; LET_END_DEF; PAIR_EQ]);;

let compat_DEF = define
 `compat ia i =
    pred_list (\(x, y). pred_list (\(xa, ya). (=) ((=) x xa) ((=) y ya)) i) ia`;;


let pr_iso_test_rec_DEF = define
 `pr_iso_test_rec i fs_1 fs_2 =
  match fs_1 with
  | [] -> null fs_2
  | (f_1 :: fs_1) ->
    list_ex
      (\f_2.
        (=) (size_list f_1) (size_list f_2) /\
          ~ (all_interval_nat
                ((~) o
                  (\n.
                    let
                      ia = zip f_1 (rotate n f_2)
                    in
                      compat ia i /\
                        pr_iso_test_rec (merge ia i) fs_1
                          (remove1 f_2 fs_2)))
                0 (size_list f_2)))
      fs_2`;;

let pr_iso_test_rec_ALT =
  (PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] o REWRITE_RULE[o_DEF]) pr_iso_test_rec_DEF;;

let pr_iso_test_DEF = define
 `pr_iso_test fs_1 fs_2 = pr_iso_test_rec [] fs_1 fs_2`;;

let iso_test_DEF = define
 `iso_test g_1 g_2 <=>
  pr_iso_test g_1 g_2 \/
    pr_iso_test g_1 (map rev g_2)`;;

let insert_mod_trie_DEF = define
 `insert_mod_trie x m =
  let k = hash x in 
  let ys = lookup m k in
    (if list_ex (iso_test x) ys
      then m else update m k (x :: ys))`;;

let insert_mod_trie_ALT = PURE_REWRITE_RULE[LET_DEF; LET_END_DEF] insert_mod_trie_DEF;;

let insert_mod2_trie_DEF = define
 `insert_mod2_trie p f x s = (if p x then insert_mod_trie (f x) s else s)`;;

let worklist_tree_coll_aux_trie_DEF = define
 `worklist_tree_coll_aux_trie succs p f =
  worklist_tree succs (insert_mod2_trie p f)`;;

let worklist_tree_coll_aux_trie_ALT = prove
  (`worklist_tree_coll_aux_trie succs p f ws gs = 
      worklist_tree succs (insert_mod2_trie p f) ws gs`,
  REWRITE_TAC[worklist_tree_coll_aux_trie_DEF]);;

let worklist_tree_coll_trie_DEF = define
 `worklist_tree_coll_trie succs p f ws =
  worklist_tree_coll_aux_trie succs p f ws (Tries [] [])`;;

let enum_filter_finals_DEF = define
 `enum_filter_finals succs =
  worklist_tree_coll_trie succs final_graph fgraph`;;

let enum_filter_finals_ALT = prove
  (`enum_filter_finals succs ws =
    worklist_tree_coll_trie succs final_graph fgraph ws`,
  REWRITE_TAC[enum_filter_finals_DEF]);;

let tameEnumFilter_DEF = define
 `tameEnumFilter p = enum_filter_finals (next_tame p) [seed p]`;;


(* Need to include additional cases *)
let f_EQ =
  let num_eq = `(=):num->num->bool` in
  let var_a_bool = `a:bool` in
  let var_xs_num_list = `xs:(num)list` in
  let var_ys_num_list = `ys:(num)list` in
  let f_const = `F` in
  let f_and = prove(`F /\ a <=> F`, REWRITE_TAC[]) in
  let t_and = prove(`T /\ a <=> a`, REWRITE_TAC[]) in
  let tf_eq = TAUT `T = F <=> F` and
      ft_eq = TAUT `F = T <=> F` in
  let refl_eq = prove(`x:A = x <=> T`, REWRITE_TAC[]) in
  let pair_eq = prove(`x:A,y:B = a,b <=> x = a /\ y = b`, REWRITE_TAC[PAIR_EQ]) in
  let option_case1 = prove(`SOME (x:A) = SOME y <=> x = y`, REWRITE_TAC[injectivity "option"]) and
      option_case2 = prove(`NONE = SOME (x:A) <=> F`, REWRITE_TAC[distinctness "option"]) and
      option_case3 = prove(`SOME (x:A) = NONE <=> F`, REWRITE_TAC[distinctness "option"]) in
  let list_case1 = prove(`CONS (x:A) xs = CONS y ys <=> x = y /\ xs = ys`, REWRITE_TAC[injectivity "list"]) and
      list_case2 = prove(`[] = CONS (x:A) xs <=> F`, REWRITE_TAC[distinctness "list"]) and
      list_case3 = prove(`CONS (x:A) xs = [] <=> F`, REWRITE_TAC[distinctness "list"]) in
  let face_case1 = prove(`Face xs Final = Face ys Final <=> xs = ys`, REWRITE_TAC[injectivity "face"]) and
      face_case2 = prove(`Face xs Nonfinal = Face ys Nonfinal <=> xs = ys`, REWRITE_TAC[injectivity "face"]) and
      face_case3 = prove(`Face xs Final = Face ys Nonfinal <=> F`, REWRITE_TAC[injectivity "face"; distinctness "facetype"]) and
      face_case4 = prove(`Face xs Nonfinal = Face ys Final <=> F`, REWRITE_TAC[injectivity "face"; distinctness "facetype"])
  in
  let rec f_EQ tm1 tm2 =
    try
      match (tm1, tm2) with
      | Comb (Const ("NUMERAL", _), _), Comb (Const ("NUMERAL", _), _) ->
        NUM_EQ_CONV (mk_comb (mk_comb (num_eq, tm1), tm2))
      | x, y when x = y ->
        let ty = type_of x in
        let var_x = mk_var ("x", ty) in
        INST[x, var_x] (INST_TYPE [ty, aty] refl_eq)
      | Const ("T", _), Const ("F", _) -> tf_eq
      | Const ("F", _), Const ("T", _) -> ft_eq
      | Comb (Comb (Const (",", Tyapp ("fun", [xty; Tyapp ("fun", [yty; _])])), x), y), Comb (Comb (Const (",", _), a), b) ->
        let var_x = mk_var ("x", xty) in
        let var_y = mk_var ("y", yty) in
        let var_a = mk_var ("a", xty) in
        let var_b = mk_var ("b", yty) in
        let th = INST [b, var_b; a, var_a; y, var_y; x, var_x] (INST_TYPE [xty, aty; yty, bty] pair_eq) in
        let rhs = rand (concl th) in
        let rhs_eq =
          let op, a2 = dest_comb rhs in
          let op, a1 = dest_comb op in
          let a1 = f_EQ x a in
          if rand (concl a1) = f_const then
            let and_th = INST[a2, var_a_bool] f_and in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), REFL a2)) and_th
          else
            let a2 = f_EQ y b in
            let and_th = INST[rand (concl a2), var_a_bool] t_and in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), a2)) and_th in
        TRANS th rhs_eq
      | Comb (Const ("SOME", Tyapp ("fun", [ty; _])), x), Comb (Const ("SOME", _), y) ->
        let var_x = mk_var ("x", ty) in
        let var_y = mk_var ("y", ty) in
        let th = INST [x, var_x; y, var_y] (INST_TYPE [ty, aty] option_case1) in
        let rhs_eq = f_EQ x y in
        TRANS th rhs_eq
      | Const ("NONE", Tyapp ("option", [ty])), Comb (Const ("SOME", _), x) ->
        let var_x = mk_var ("x", ty) in
        INST[x, var_x] (INST_TYPE [ty, aty] option_case2)
      | Comb (Const ("SOME", _), x), Const ("NONE", Tyapp ("option", [ty])) ->
        let var_x = mk_var ("x", ty) in
        INST[x, var_x] (INST_TYPE [ty, aty] option_case3)
      | Comb (Comb (Const ("CONS", Tyapp ("fun", [xty; Tyapp ("fun", [xsty; _])])), x), xs), Comb (Comb (Const ("CONS", _), y), ys) ->
        let var_x = mk_var ("x", xty) in
        let var_y = mk_var ("y", xty) in
        let var_xs = mk_var ("xs", xsty) in
        let var_ys = mk_var ("ys", xsty) in
        let th = INST [ys, var_ys; xs, var_xs; y, var_y; x, var_x] (INST_TYPE [xty, aty] list_case1) in
        let rhs = rand (concl th) in
        let rhs_eq =
          let op, a2 = dest_comb rhs in
          let op, a1 = dest_comb op in
          let a1 = f_EQ x y in
          if rand (concl a1) = f_const then
            let and_th = INST[a2, var_a_bool] f_and in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), REFL a2)) and_th
          else
            let a2 = f_EQ xs ys in
            let and_th = INST[rand (concl a2), var_a_bool] t_and in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), a2)) and_th in
        TRANS th rhs_eq
      | Const ("NIL", (Tyapp ("list", [xty]) as xsty)), Comb (Comb (Const ("CONS", _), x), xs) ->
        let var_x = mk_var ("x", xty) in
        let var_xs = mk_var ("xs", xsty) in
        INST[x, var_x; xs, var_xs] (INST_TYPE [xty, aty] list_case2)
      | Comb (Comb (Const ("CONS", _), x), xs), Const ("NIL", (Tyapp ("list", [xty]) as xsty)) ->
        let var_x = mk_var ("x", xty) in
        let var_xs = mk_var ("xs", xsty) in
        INST[x, var_x; xs, var_xs] (INST_TYPE [xty, aty] list_case3)
      | Comb (Comb (Const ("Face", _), xs), Const ("Final", _)), Comb (Comb (Const ("Face", _), ys), Const ("Final", _)) ->
        let th = INST[xs, var_xs_num_list; ys, var_ys_num_list] face_case1 in
        let rhs_eq = f_EQ xs ys in
        TRANS th rhs_eq
      | Comb (Comb (Const ("Face", _), xs), Const ("Nonfinal", _)), Comb (Comb (Const ("Face", _), ys), Const ("Nonfinal", _)) ->
        let th = INST[xs, var_xs_num_list; ys, var_ys_num_list] face_case2 in
        let rhs_eq = f_EQ xs ys in
        TRANS th rhs_eq
      | Comb (Comb (Const ("Face", _), xs), Const ("Final", _)), Comb (Comb (Const ("Face", _), ys), Const ("Nonfinal", _)) ->
        INST[xs, var_xs_num_list; ys, var_ys_num_list] face_case3
      | Comb (Comb (Const ("Face", _), xs), Const ("Nonfinal", _)), Comb (Comb (Const ("Face", _), ys), Const ("Final", _)) ->
        INST[xs, var_xs_num_list; ys, var_ys_num_list] face_case4
      | _ -> failwith "No match: f_EQ"
    with
    | Failure msg -> eval_error msg "f_EQ" [tm1; tm2]
    | Eval_error err -> eval_error_propagate err "f_EQ" [tm1; tm2]
     in
  f_EQ;;

let rules = [
  "APPEND", APPEND;
  "map_of_DEF", map_of_DEF;
  "the_DEF", the_DEF;
  "is_none_DEF", is_none_DEF;
  "funpow_ALT", funpow_ALT;
  "nth_DEF", nth_DEF;
  "fold_DEF", fold_DEF;
  "rev_DEF", rev_DEF;
  "upt_DEF", upt_DEF;
  "zip_ALT", zip_ALT;
  "null_DEF", null_DEF;
  "last_DEF", last_DEF;
  "maps_DEF", maps_DEF;
  "foldl_DEF", foldl_DEF;
  "foldr_ALT", foldr_ALT;
  "concat_DEF", concat_DEF;
  "filter_DEF", filter_DEF;
  "member_ALT", member_ALT;
  "rotate1_DEF", rotate1_DEF;
  "rotate_ALT", rotate_ALT;
  "hd_DEF", hd_DEF;
  "tl_DEF", tl_DEF;
  "list_ex_ALT", list_ex_ALT;
  "remdups_DEF", remdups_DEF;
  "remove1_DEF", remove1_DEF;
  "map_DEF", map_DEF;
  "pred_list_ALT", pred_list_ALT;
  "replicate_DEF", replicate_DEF;
  "gen_length_DEF", gen_length_DEF;
  "map_filter_ALT", map_filter_ALT;
  "list_update_DEF", list_update_DEF;
  "all_interval_nat_ALT", all_interval_nat_ALT;
  "size_list_DEF", size_list_DEF;
  "fst_DEF", fst_DEF;
  "snd_DEF", snd_DEF;
  "mapAt_DEF", mapAt_DEF;
  "splitAtRec_DEF", splitAtRec_DEF;
  "splitAt_DEF", splitAt_DEF;
  "between_ALT", between_ALT;
  "minimall_ALT", minimall_ALT;
  "replace_DEF", replace_DEF;
  "removeKey_DEF", removeKey_DEF;
  "removeKeyList_DEF", removeKeyList_DEF;

  "vertices_face_DEF", vertices_face_DEF;
  "final_face_DEF", final_face_DEF;
  "faceListAt_DEF", faceListAt_DEF;
  "facesAt_DEF", facesAt_DEF;
  "tri_ALT", tri_ALT;
  "quad_ALT", quad_ALT;
  "faces_DEF", faces_DEF;
  "graph_ALT", graph_ALT;
  "degree_DEF", degree_DEF;
  "except_ALT", except_ALT;
  "finals_DEF", finals_DEF;
  "heights_DEF", heights_DEF;
  "height_DEF", height_DEF;
  "nextElem_ALT", nextElem_ALT;
  "setFinal_DEF", setFinal_DEF;
  "nextVertex_ALT", nextVertex_ALT;
  "neighbors_DEF", neighbors_DEF;
  "nonFinals_DEF", nonFinals_DEF;
  "vertextype_DEF", vertextype_DEF;
  "finalVertex_DEF", finalVertex_DEF;
  "final_graph_DEF", final_graph_DEF;
  "nextVertices_DEF", nextVertices_DEF;
  "countVertices_DEF", countVertices_DEF;
  "directedLength_DEF", directedLength_DEF;
  "vertices_graph_DEF", vertices_graph_DEF;

  "tame10_ALT", tame10_ALT;
  "tame11a_DEF", tame11a_DEF;
  "tame11b_DEF", tame11b_DEF;
  "tame12o_DEF", tame12o_DEF;
  "tame10ub_DEF", tame10ub_DEF;
  "excessTCount_DEF", excessTCount_DEF;
  "squanderTarget_DEF", squanderTarget_DEF;
  "squanderFace_ALT", squanderFace_ALT;
  "squanderVertex_ALT", squanderVertex_ALT;
  "maxGon_DEF", maxGon_DEF;
  "seed_DEF", seed_DEF;
  "duplicateEdge_DEF", duplicateEdge_DEF;
  "containsUnacceptableEdgeSnd_ALT", containsUnacceptableEdgeSnd_ALT;
  "containsUnacceptableEdge_ALT", containsUnacceptableEdge_ALT;
  "containsDuplicateEdge_DEF", containsDuplicateEdge_DEF;

  "alist_DEF", alist_DEF;
  "values_DEF", values_DEF;
  "lookup_ALT", lookup_ALT;
  "rem_alist_DEF", rem_alist_DEF;
  "update_ALT", update_ALT;

  "minimalFace_ALT", minimalFace_ALT;
  "minimalVertex_DEF", minimalVertex_DEF;
  "listSum_DEF", listSum_DEF;
  "heightsNewVertices_DEF", heightsNewVertices_DEF;
  "replacefacesAt_DEF", replacefacesAt_DEF;
  "split_face_ALT", split_face_ALT;
  "splitFace_ALT", splitFace_ALT;
  "makeFaceFinalFaceList_DEF", makeFaceFinalFaceList_DEF;
  "makeFaceFinal_DEF", makeFaceFinal_DEF;
  "subdivFacea_ALT", subdivFacea_ALT;
  "subdivFace_DEF", subdivFace_DEF;

  "enumAppend_DEF", enumAppend_DEF;
  "enumBase_DEF", enumBase_DEF;
  "enumerator_ALT", enumerator_ALT;
  "enum_ALT", enum_ALT;

  "hideDupsRec_DEF", hideDupsRec_DEF;
  "hideDups_DEF", hideDups_DEF;
  "indexToVertexList_DEF", indexToVertexList_DEF;
  "notame_DEF", notame_DEF;
  "excessAtType_ALT", excessAtType_ALT;
  "excessAt_DEF", excessAt_DEF;
  "faceSquanderLowerBound_DEF", faceSquanderLowerBound_DEF;
  "deleteAround_ALT", deleteAround_ALT;
  
  "excessNotAtRec_ALT", excessNotAtRec_ALT;
  "excessTable_ALT", excessTable_ALT;
  "excessNotAt_ALT", excessNotAt_ALT;
  "squanderLowerBound_DEF", squanderLowerBound_DEF;
  "polysizes_ALT", polysizes_ALT;
  "is_tame13a_ALT", is_tame13a_ALT;
  "generatePolygonTame_ALT", generatePolygonTame_ALT;
  "next_tame0_ALT", next_tame0_ALT;
  "is_tame_DEF", is_tame_DEF;
  "next_tame_ALT", next_tame_ALT;
  "worklist_tree_aux_DEF", worklist_tree_aux_DEF;
  "worklist_tree_ALT", worklist_tree_ALT;
  "nof_vertices_ALT", nof_vertices_ALT;

  "qsort_DEF", qsort_DEF;
  "hash_ALT", hash_ALT;
  "fgraph_DEF", fgraph_DEF;
  "merge_ALT", merge_ALT;
  "compat_DEF", compat_DEF;

  "pr_iso_test_rec_ALT", pr_iso_test_rec_ALT;
  "pr_iso_test_DEF", pr_iso_test_DEF;
  "iso_test_DEF", iso_test_DEF;
  "insert_mod_trie_ALT", insert_mod_trie_ALT;
  "insert_mod2_trie_DEF", insert_mod2_trie_DEF;
  "worklist_tree_coll_aux_trie_ALT", worklist_tree_coll_aux_trie_ALT;
  "worklist_tree_coll_trie_DEF", worklist_tree_coll_trie_DEF;
  "enum_filter_finals_ALT", enum_filter_finals_ALT;
  "tameEnumFilter_DEF", tameEnumFilter_DEF;
];;

let const_names = 
  List.map (fun (n, th) ->
    let th0 = hd (BODY_CONJUNCTS th) in
    let const, _ = strip_comb (lhand (concl th0)) in
    let name, _ = dest_const const in
    name) rules;;

let db = add_thms (default_db ()) rules;;


write_rules db "out.hl" (List.map (fun n -> [n]) const_names);;
loadt "out.hl";;


needs "out.hl";;
compile_term db "t" `pred_list (\x. x <= 10) [1;2;4;3]` |> print_expr Format.std_formatter;;
compile_term db "t" `map_filter (\x. if x <= 10 then SOME (x + 2) else NONE) [1;2;4;3]` |> print_expr Format.std_formatter;;

let tm = `Graph [] 0 [[Face [1;2] Final]; [Face [3] Nonfinal]] [1;2]`;;
let tm2 = rand (concl (f_graph `4`));;

f_is_none `NONE`;;
f_between `[1;2;3]` `1` `3`;;

f_tri `Graph [] 0 [[Face [1;2] Final]; [Face [3] Nonfinal]] [1;2]` `1`;;
f_facesAt tm `1`;;
f_degree tm2 `1`;;
f_except tm2 `1`;;
f_finals tm2;;
f_heights tm;;
f_height tm `1`;;
f_nextElem `[1;2;3]` `0` `2`;;
f_setFinal `Face [1;2] Nonfinal`;;
f_nextVertex `Face [1;2;3;4] Final` `4`;;
f_neighbors tm2 `2`;;
f_nonFinals tm2;;
f_vertextype tm2 `1`;;
f_finalVertex tm2 `0`;;
f_final_graph tm2;;
f_nextVertices `Face [1;2;3;4] Nonfinal` `3` `2`;;
f_countVertices tm2;;
f_directedLength `Face [1;2;3;4] Nonfinal` `1` `2`;;
f_vertices_graph tm2;;
f_tame10 tm;;
f_tame11a tm2;;
f_tame11b tm2;;
f_tame12o tm2;;
f_tame10ub tm2;;
f_excessTCount;;
f_squanderTarget;;
f_squanderFace `1`;;
f_squanderVertex `1` `20`;;
f_maxGon `3`;;
f_seed `0`;;
f_duplicateEdge tm2 `Face [1;2] Nonfinal` `1` `2`;;
f_containsUnacceptableEdgeSnd (`>`, f_GT) `1` `[1;2;3;4;5]`;;
f_containsUnacceptableEdge (`<=`, f_LE) `[1;2;3;4]`;;
f_containsDuplicateEdge tm2 `Face [1;2] Nonfinal` `1` `[1;2;3]`;;

let trie = `Tries [0] [1, Tries [1;2] []; 2, Tries [4] []]`;;
type_of trie;;
f_alist trie;;
f_values trie;;
f_lookup trie `[2]`;;
f_rem_alist `1` `[2,2;5,3;1,1;3,4]`;;
f_update trie `[1]` `[2;5]`;;

f_minimalFace `[Face [1;2] Final; Face [2;3;4] Nonfinal; Face [1] Final]`;;
f_minimalVertex tm2 `Face [1;2;3] Final`;;
f_listSum `[1;2;3]` (`SUC`, f_SUC);;
f_heightsNewVertices `1` `4` `4`;;
f_replacefacesAt `[1;2;3]` `1` `[1]` `[[2]]`;;
f_split_face `Face [1;2;3;4] Final` `2` `4` `[5;6]`;;
f_splitFace tm2 `1` `2` `Face [1;2;3] Nonfinal` `[1;2]`;;
f_makeFaceFinalFaceList `Face [1;2;3] Final` `[Face [1;2;3] Nonfinal]`;;
f_makeFaceFinal `Face [3] Nonfinal` tm;;
f_subdivFace tm2 `Face [3;2;1;0] Nonfinal` `[SOME 1; NONE; SOME 3]`;;

f_enumAppend `5` `[[1; 2; 3; 2]; [0]]`;;
f_enumerator `5` `7`;;
f_enum `5` `7`;;

f_hideDups `[1;2;3;3;3;4;3]`;;
f_indexToVertexList `Face [1;2;3] Nonfinal` `2` `[1;2;0;0]`;;
f_notame tm2;;
f_excessAtType `2` `4` `0`;;
f_excessAt tm2 `3`;;
f_faceSquanderLowerBound tm2;;
f_deleteAround tm2 `1` `[1,2; 0,3]`;;

f_excessNotAtRec `[1,2; 3,4]` tm2;;
f_excessTable tm `[0;1]`;;
f_excessNotAt tm `SOME 0`;;
f_squanderLowerBound tm2;;
f_polysizes `1` tm2;;
f_is_tame13a tm2;;
f_generatePolygonTame `1` `0` `Face [1;2] Final` tm;;
f_next_tame0 `2` tm2;;
f_is_tame tm2;;
f_next_tame `0` tm2;;
f_nof_vertices `[[1;2]; [3]; [0;1]]`;;

f_qsort (`>`, f_GT) `[1;0;3;2;4;1]`;;
f_hash `[[1;2;3]; [1]; [2;3;4]]`;;
f_fgraph tm2;;
f_merge `[1,2; 5,1]` `[3,4; 1,3]`;;
f_compat `[1,2; 5,1]` `[5,4; 1,3]`;;

f_pr_iso_test `[[1;2];[3]]` `[[2;1];[2]]`;;
f_iso_test `[[1;2];[2]]` `[[2;1];[2]]`;;

let trie = `Tries [[[0]]] [1, Tries [[[1;2]]] []; 2, Tries [[[4]]] []]`;;
f_insert_mod_trie `[[1]]` trie;;

f_tameEnumFilter `0`;;