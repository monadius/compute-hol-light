(* load_path := "/Users/monad/Work/git/formal_ineqs" :: !load_path;; *)
needs "tame_defs.hl";;
needs "tame_defs_unrolled.hl";;
loadt "test_tame_support.hl";;

let rules = [
  "APPEND_UNROLL8", APPEND_UNROLL8, [];
  "map_of_DEF", map_of_DEF, [];
  "the_DEF", the_DEF, [];
  "is_none_DEF", is_none_DEF, [];
  "funpow_UNROLL5", funpow_UNROLL5, [];
  "nth_UNROLL15", nth_UNROLL15, [];
  "fold_DEF", fold_DEF, [];
  "rev_DEF", rev_DEF, [];
  "upt_DEF", upt_DEF, [];
  "zip_ALT", zip_ALT, [];
  "null_DEF", null_DEF, [];
  "last_DEF", last_DEF, [];
  "maps_UNROLL7", maps_UNROLL7, [];
  "foldl_DEF", foldl_DEF, [];
  "foldr_ALT", foldr_ALT, [];
  "concat_DEF", concat_DEF, [];
  "filter_DEF", filter_DEF, [];
  "member_DEF", member_DEF, [];
  "rotate1_DEF", rotate1_DEF, [];
  "rotate_ALT", rotate_ALT, [];
  "bool_to_num_DEF", bool_to_num_DEF, [];
  "count_UNROLL7", count_UNROLL7, [];
  "hd_DEF", hd_DEF, [];
  "tl_DEF", tl_DEF, [];
  "list_ex_DEF", list_ex_DEF, [];
  "remdups_DEF", remdups_DEF, [];
  "remove1_DEF", remove1_DEF, [];
  "map_UNROLL11", map_UNROLL11, [];
  "pred_list_UNROLL11", pred_list_UNROLL11, [];
  "replicate_DEF", replicate_DEF, [];
  "gen_length_DEF", gen_length_DEF, [];
  "map_filter_DEF", map_filter_DEF, [];
  (* "map_filter_ALT", map_filter_ALT, []; *)
  "list_update_DEF", list_update_DEF, [];
  "all_interval_nat_DEF", all_interval_nat_DEF, [];
  "size_list_UNROLL15", size_list_UNROLL15, [];
  "fst_DEF", fst_DEF, [];
  "snd_DEF", snd_DEF, [];
  "mapAt_DEF", mapAt_DEF, [];
  "splitAtRec_DEF", splitAtRec_DEF, [];
  "splitAt_DEF", splitAt_DEF, [];
  "between_ALT", between_ALT, [];
  "minimall_ALT", minimall_ALT, [];
  "replace_DEF", replace_DEF, [];
  "removeKey_DEF", removeKey_DEF, [];
  "removeKeyList_DEF", removeKeyList_DEF, [];

  "vertices_face_DEF", vertices_face_DEF, [];
  "final_face_DEF", final_face_DEF, [];
  "faceListAt_DEF", faceListAt_DEF, [];
  "facesAt_DEF", facesAt_DEF, [];
  "tri_ALT", tri_ALT, [];
  "quad_ALT", quad_ALT, [];
  "faces_DEF", faces_DEF, [];
  "graph_ALT", graph_ALT, [];
  "degree_DEF", degree_DEF, [];
  "except_ALT", except_ALT, [];
  "finals_DEF", finals_DEF, [];
  "heights_DEF", heights_DEF, [];
  "height_DEF", height_DEF, [];
  "nextElem_ALT", nextElem_ALT, [];
  "setFinal_DEF", setFinal_DEF, [];
  "nextVertex_ALT", nextVertex_ALT, [];
  "neighbors_DEF", neighbors_DEF, [];
  "nonFinals_DEF", nonFinals_DEF, [];
  "vertextype_DEF", vertextype_DEF, [];
  "finalVertex_DEF", finalVertex_DEF, [];
  "final_graph_ALT", final_graph_ALT, [];
  "nextVertices_DEF", nextVertices_DEF, [];
  "countVertices_DEF", countVertices_DEF, [];
  "directedLength_DEF", directedLength_DEF, [];
  "vertices_graph_DEF", vertices_graph_DEF, [];

  "tame10_ALT", tame10_ALT, [];
  "tame11a_DEF", tame11a_DEF, [];
  "tame11b_DEF", tame11b_DEF, [];
  "tame12o_ALT", tame12o_ALT, [];
  "tame10ub_DEF", tame10ub_DEF, [];
  "excessTCount_DEF", excessTCount_DEF, [];
  "squanderTarget_DEF", squanderTarget_DEF, [];
  "squanderFace_ALT", squanderFace_ALT, [];
  "squanderVertex_ALT", squanderVertex_ALT, [];
  "maxGon_ALT", maxGon_ALT, [];
  "seed_DEF", seed_DEF, [];
  "duplicateEdge_DEF", duplicateEdge_DEF, [];
  "containsUnacceptableEdgeSnd_ALT", containsUnacceptableEdgeSnd_ALT, [];
  "containsUnacceptableEdge_ALT", containsUnacceptableEdge_ALT, [];
  "containsDuplicateEdge_DEF", containsDuplicateEdge_DEF, [];

  "alist_DEF", alist_DEF, [];
  "values_DEF", values_DEF, [];
  "lookup_DEF", lookup_DEF, [];
  (* "lookup_ALT", lookup_ALT, []; *)
  "rem_alist_DEF", rem_alist_DEF, [];
  "update_DEF", update_DEF, [];
  (* "update_ALT", update_ALT, []; *)

  "minimalFace_ALT", minimalFace_ALT, [];
  "minimalVertex_DEF", minimalVertex_DEF, [];
  "listSum_DEF", listSum_DEF, [];
  "heightsNewVertices_DEF", heightsNewVertices_DEF, [];
  "replacefacesAt_DEF", replacefacesAt_DEF, [];
  "split_face_ALT", split_face_ALT, [];
  "splitFace_ALT", splitFace_ALT, [];
  "makeFaceFinalFaceList_DEF", makeFaceFinalFaceList_DEF, [];
  "makeFaceFinal_DEF", makeFaceFinal_DEF, [];
  "subdivFacea_ALT", subdivFacea_ALT, [];
  "subdivFace_DEF", subdivFace_DEF, [];

  "enumAppend_DEF", enumAppend_DEF, [];
  "enumBase_DEF", enumBase_DEF, [];
  "enumerator_ALT", enumerator_ALT, [];
  "enum_ALT", enum_ALT, [];

  "hideDupsRec_DEF", hideDupsRec_DEF, [];
  "hideDups_DEF", hideDups_DEF, [];
  "indexToVertexList_DEF", indexToVertexList_DEF, [];
  "notame_DEF", notame_DEF, [];
  "excessAtType_ALT", excessAtType_ALT, [];
  "excessAt_DEF", excessAt_DEF, [];
  "faceSquanderLowerBound_DEF", faceSquanderLowerBound_DEF, [];
  "deleteAround_ALT", deleteAround_ALT, [];
  
  "excessNotAtRec_ALT", excessNotAtRec_ALT, [];
  "excessTable_ALT", excessTable_ALT, [];
  "excessNotAt_ALT", excessNotAt_ALT, [];
  "squanderLowerBound_DEF", squanderLowerBound_DEF, [];
  "polysizes_ALT", polysizes_ALT, [];
  "is_tame13a_ALT", is_tame13a_ALT, [];
  "generatePolygonTame_ALT", generatePolygonTame_ALT, [];
  "next_tame0_ALT", next_tame0_ALT, [];
  "is_tame_DEF", is_tame_DEF, [];
  "next_tame_ALT", next_tame_ALT, [];
  "worklist_tree_aux_DEF", worklist_tree_aux_DEF, [];
  "worklist_tree_ALT", worklist_tree_ALT, [];
  "nof_vertices_ALT", nof_vertices_ALT, [];

  "qsort_DEF", qsort_DEF, [];
  "hash_ALT", hash_ALT, [];
  "fgraph_DEF", fgraph_DEF, [];
  "merge_ALT", merge_ALT, [];
  "compat_DEF", compat_DEF, [];

  "pr_iso_test_rec_ALT", pr_iso_test_rec_ALT, [];
  "pr_iso_test_DEF", pr_iso_test_DEF, [];
  "iso_test_DEF", iso_test_DEF, [];
  "insert_mod_trie_ALT", insert_mod_trie_ALT, [];
  (* "insert_mod2_trie_DEF", insert_mod2_trie_DEF;
  "worklist_tree_coll_aux_trie_ALT", worklist_tree_coll_aux_trie_ALT;
  "worklist_tree_coll_trie_DEF", worklist_tree_coll_trie_DEF;
  "enum_filter_finals_ALT", enum_filter_finals_ALT; *)
  "tameEnumFilter_ALT", tameEnumFilter_ALT, [];

  "worklist_tree_bounded_ALT", worklist_tree_bounded_ALT, [];
  "tameEnumFilterBounded_DEF", tameEnumFilterBounded_DEF, [];
  "tameCountFinalsBounded_DEF", tameCountFinalsBounded_DEF, [];
];;

let db = add_thms (tame_default_db ~eliminate_abs:true ()) rules;;
let consts = dependencies db `tameEnumFilterBounded`;;
(* let consts = dependencies db `tameEnumFilterBounded` ~inst_types:false *)
set_extra_for_consts db (Extra_memo (Assoc_memo 10000)) [
(* set_extra_for_consts db (Extra_memo (Assoc_lru (10000, 2))) [ *)
(* set_extra_for_consts db (Extra_memo Hashtbl_memo) [ *)
  (* `bool_to_num`; *)
  (* `fst:num#num->num`; *)
  (* `is_none:(num#num)option->bool`; *)
  (* `final_face`; *)
  `size_list:(num)list->num`;
  `excessAtType`;
  `vertices_face`;
  `heightsNewVertices`;
  `upt`;
  (* `nextElem:(num)list->num->num->num`; *)
  `nextVertex`;
  `rev:(num)list->(num)list`;
  `APPEND:(num)list->(num)list->(num)list`;
  `nextVertices`;
  `member:(num)list->num->bool`;
  `enum`;
  (* `nth:(num)list->num->num`; *)
  (* `faceListAt`; *)
  `splitAtRec:num->(num)list->(num)list->(num)list#(num)list`;
  `map:(num->(num)list)->(num)list->((num)list)list`;
  `map:((num)list->(num)list)->((num)list)list->((num)list)list`;
  (* `filter:(num#num->bool)->(num#num)list->(num#num)list`; *)

  (* `removeKeyList:(num)list->(num#num)list->(num#num)list`; *)

  (* `nth:((face)list)list->num->(face)list`; *)
  (* `excessNotAtRec`; *)
];;

let () =
  set_extra_for_all db (Extra_counter 0);
  set_extra_for_names db (Extra_counter 100) ["worklist_tree_bounded"];
  (* set_rule db `(=):A->A->bool`; *)
  (* set_extra_for_all db Extra_arg_list; *)
  (* write_rules_names db "out.hl" const_names *)
  write_rules_consts db "out_2.hl" consts;;
loadt "out_2.hl";;

(* 40.714s *)
(* original: 0.0171s *)
(* ratio: 2381 *)

(* 26.144s with COND instead of AND/OR *)
(* 25.406s with new AND/OR *)
(* 23.614s with size_list_ALT with 15 cases *)
(* 18.631s with custom types (COND, f_EQ still use INST_TYPE) *)
(* 17.927s with custom types (including COND but without f_EQ) *)
(* 17.995s with custom types everywhere *)
(* 14.663s with nth_ALT with 10 cases *)
(* 14.538s with funpow_ALT2 with 5 cases *)
(* 14.487s with maps_ALT, count_ALT, map_ALT, pred_list_ALT *)
(* 9.915s with fast arithmetic *)
(* 9.859s with fast arithmetic + standardize *)
(* 9.797s with APPEND_UNROLL8 *)
(* 9.653s with nth_UNROLL15, maps_UNROLL7, count_UNROLL7 *)
(* 8.874s with memos *)
(* 3.275s with eliminate_abs and without memos *)
(* 3.246s with Weak_memo *)
(* 2.649s with Hashtbl_memo *)
(* 2.688s with Assoc_memo *)
(* 2.481s with eval_compile_tree *)
(* reset_core_counters() *)
let () = ();;
let () =
  reset_all_counters();
  clear_arg_lists();
  clear_all_memos();
  clear_weak_memos();
  clear_lru_memos();
  clear_assoc_memos();;
test 1 (f_tameEnumFilterBounded (numeral `0`)) (numeral `100`);;

(* 397s with Weak_memo *)
(* 255s with Hashtbl_memo *)
(* 262s with Assoc_memo *)
(* 263s with Assoc_lru 10000, 2 *)
test 1 (f_tameEnumFilterBounded (numeral `0`)) (numeral `10000`);;
test 1 (f_tameEnumFilterBounded `0`) `100`;;

(* 518s with Hashtbl_memo *)
(* 517s without memo for removeKeyList *)
(* 530s with Assoc_memo *)
(* 594s with Assoc_lru 10000, 5*)
(* 597s with Assoc_lru 10000, 2*)
(* 478s with tail rec main loop with Assoc *)
(* 451s with tail rec, Assoc (another run) *)
test 1 (f_tameEnumFilterBounded (numeral `0`)) (numeral `20000`);;

let f_worklist_tree_bounded_graph_num_num_list_list_tries =
  let worklist_tree_bounded_ALT_case1, worklist_tree_bounded_ALT_case2 =
    match map standardize (inst_type_thms `:num->(graph->(graph)list)->(graph->(num,((num)list)list)tries->(num,((num)list)list)tries)->(graph)list->(num,((num)list)list)tries->(num,((num)list)list)tries` (local_split_thm worklist_tree_bounded_ALT)) with
    | [th1; th2] -> (th1, th2)
    | _ -> failwith "error"
     in
  let var_e = standardize_tm (mk_var ("e", `:(num,((num)list)list)tries`)) in
  let var_t = standardize_tm (mk_var ("t", `:(num,((num)list)list)tries`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let var_succs = standardize_tm (mk_var ("succs", `:graph->(graph)list`)) in
  let var_f = standardize_tm (mk_var ("f", `:graph->(num,((num)list)list)tries->(num,((num)list)list)tries`)) in
  let var_x = standardize_tm (mk_var ("x", `:graph`)) in
  let var_wsa = standardize_tm (mk_var ("wsa", `:(graph)list`)) in
  let var_s = standardize_tm (mk_var ("s", `:(num,((num)list)list)tries`)) in
  let COND_num_num_list_list_tries_T = standardize (INST_TYPE [`:(num,((num)list)list)tries`, aty] COND_T) in
  let COND_num_num_list_list_tries_F = standardize (INST_TYPE [`:(num,((num)list)list)tries`, aty] COND_F) in
  let counter_f_worklist_tree_bounded_graph_num_num_list_list_tries = create_counter "f_worklist_tree_bounded_graph_num_num_list_list_tries" in
  let rec f_worklist_tree_bounded final_th tm1 tm2 tm3 tm4 tm5 =
    let () = incr counter_f_worklist_tree_bounded_graph_num_num_list_list_tries in
    let () = if !counter_f_worklist_tree_bounded_graph_num_num_list_list_tries mod 100 = 0 then Format.printf "%d       \r@?" !counter_f_worklist_tree_bounded_graph_num_num_list_list_tries in
    match (tm1, tm2, tm3, tm4, tm5) with
    | (n, (succs, func_succs), (f, func_f), Const ("NIL", _), s) -> TRANS final_th (INST [s, var_s; f, var_f; succs, var_succs; n, var_n] worklist_tree_bounded_ALT_case1)
    | (n, (succs, func_succs), (f, func_f), Comb (Comb (Const ("CONS", _), x), wsa), s) ->
      let th = INST [s, var_s; x, var_x; f, var_f; succs, var_succs; n, var_n; wsa, var_wsa] worklist_tree_bounded_ALT_case2 in
      begin
        match concl th with
        | Comb (_, Comb (Comb (Comb (a2, _), _), (Comb (Comb (Comb (Comb (Comb (a5, Comb (_, (Comb (_, a1) as a3))), _), _), Comb (Comb (a4, _), _)), _) as a6))) ->
          let r1 = f_EQ_num n a1 in
          if is_true_th r1 then
            let th0 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL s), REFL a6) in
            let th1 = INST [(s, var_t); (a6, var_e)] COND_num_num_list_list_tries_T in
            TRANS final_th (TRANS th (TRANS th0 th1))
          else
            let r2 = f_SUB n a3 in
            let r3 = (succs, func_succs) in
            let r4 = (f, func_f) in
            let r5 = func_succs x in
            let r6 =
              let r6 = f_APPEND_graph (rand (concl r5)) wsa in
              TRANS (MK_COMB (MK_COMB (REFL a4, r5), REFL wsa)) r6 in
            let r7 = func_f x s in
            let th1 = MK_COMB (MK_COMB (MK_COMB (REFL a2, r1), REFL s), REFL a6) in
            let cond_th = INST[s, var_t; a6, var_e] COND_num_num_list_list_tries_F in
            let th2 = MK_COMB (MK_COMB (MK_COMB (MK_COMB (MK_COMB (REFL a5, r2), REFL succs), REFL f), r6), r7) in
            let th3 = TRANS th (TRANS th1 (TRANS cond_th th2)) in
            f_worklist_tree_bounded (TRANS final_th th3) (rand (concl r2)) r3 r4 (rand (concl r6)) (rand (concl r7))
        | _ -> failwith "bad pattern"
      end
    | _ -> failwith "No match: f_worklist_tree_bounded"
  in
  let op, _ = concl worklist_tree_bounded_ALT_case1 |> lhand |> strip_comb in
  fun tm1 (tm2, f2) (tm3, f3) tm4 tm5 ->
    let tm = list_mk_comb (op, [tm1; tm2; tm3; tm4; tm5]) in
    f_worklist_tree_bounded (REFL tm) tm1 (tm2, f2) (tm3, f3) tm4 tm5
;;

let f_tameEnumFilterBounded =
  let no_abs_tameEnumFilterBounded_DEF_case1 =
    match map standardize (local_split_thm no_abs_tameEnumFilterBounded_DEF) with
    | [th1] -> th1
    | _ -> failwith "error"
     in
  let var_p = standardize_tm (mk_var ("p", `:num`)) in
  let var_n = standardize_tm (mk_var ("n", `:num`)) in
  let counter_f_tameEnumFilterBounded = create_counter "f_tameEnumFilterBounded" in
  let rec f_tameEnumFilterBounded p n =
    try
      let () = incr counter_f_tameEnumFilterBounded in
      let th = INST [p, var_p; n, var_n] no_abs_tameEnumFilterBounded_DEF_case1 in
      let rhs_eq =
        match concl th with
        | Comb (_, Comb (Comb ((Comb (Comb (_, a1), a2) as a5), Comb (Comb (a3, _), a4)), a6)) ->
          let r1 = (a1, f_next_tame p) in
          let r2 = (a2, f_tameEnumFilter_abs1) in
          let r3 = f_seed p in
          let r4 = MK_COMB (MK_COMB (REFL a3, r3), REFL a4) in
          let r5 = f_worklist_tree_bounded_graph_num_num_list_list_tries n r1 r2 (rand (concl r4)) a6 in
          TRANS (MK_COMB (MK_COMB (REFL a5, r4), REFL a6)) r5
        | _ -> failwith "bad pattern"
         in
      TRANS th rhs_eq
    with
    | Failure msg -> eval_error msg "f_tameEnumFilterBounded" [p; n]
    | Eval_error err -> eval_error_propagate err "f_tameEnumFilterBounded" [p; n]
     in
  f_tameEnumFilterBounded
;;

(* 100000: 2908s (non-exclusive) *)
(* all: 11493s *)
test 1 (f_tameEnumFilterBounded (numeral `0`)) (numeral `100000`);;

let res, tm = it;;

let rec all_values tm =
  let op, al = dest_comb tm in
  let _, vs = dest_comb op in
  dest_list vs @ 
    (List.fold_left (@) [] (map (all_values o snd o dest_pair) (dest_list al)));;

all_values (rand (concl res));;

let all_values =
  `all_values (Tries vs al) = APPEND vs (maps (\(_, t). all_values t) al)`;;

(* After 241000 steps *)
(* 31106 *)
Hashtbl.length (create_memo "f_APPEND_num");;
(* 12 *)
Hashtbl.length (create_memo "f_map_num_num_list");;
(* 138 *)
Hashtbl.length (create_memo "f_upt");;
(* 23 *)
Hashtbl.length (create_memo "f_map_num_list_num_list");;
(* 15 *)
Hashtbl.length (create_memo "f_heightsNewVertices");;
(* 2518 *)
Hashtbl.length (create_memo "f_size_list_num");;
(* 9303 *)
Hashtbl.length (create_memo "f_nextVertex");;
(* 4108 *)
Hashtbl.length (create_memo "f_vertices_face");;
(* 3263591 *)
Hashtbl.length (create_memo "f_removeKeyList_num_num");;
(* 5 *)
Hashtbl.length (create_memo "f_squanderVertex");;
(* 5 *)
Hashtbl.length (create_memo "f_excessAtType");;
(* 52 *)
Hashtbl.length (create_memo "f_rev_num");;
(* 164240 *)
Hashtbl.length (create_memo "f_member_num");;
(* 32459 *)
Hashtbl.length (create_memo "f_splitAtRec_num");;
(* 1 *)
Hashtbl.length (create_memo "f_squanderFace");;

Hashtbl.length (create_memo "f_maxGon");;

let get_thms name =
  let m = create_memo name in
  Hashtbl.fold (fun k v r -> v :: r) m [];;

get_thms "f_maxGon";;

(* New orda improves performance *)
(* type_of 5566376 *)
(* type_of 2913467 with new MK_COMB *)
(* No significant difference in performance *)
core_counters();;
reset_core_counters();;

time (f_tameEnumFilterBounded `0`) `100000`;;
setify_types !eq_types;;

get_all_counters();;
get_counter "f_gen_length";;
Hashtbl.fold (fun k v r -> k :: r) (create_memo "f_size_list") [];;

(* nth -> unroll up to 15 *)
(* maps -> up to 7 *)
(* count -> up to 7 *)

analyze_arg_lists();;

let args = lazy !(create_arg_list "f_squanderVertex");;
let n = Lazy.force args |> length;;
Lazy.force args |> map (length o dest_list o el 0) |> freqs;;
Lazy.force args |> map (Nat_arith.dest_nat o el 0) |> freqs;;
Lazy.force args |> freqs;;
let t = Lazy.force args |> freqs |> length;;
float (n - t) /. float n;;

Nat_arith.reset_cache();;

setify !cond_types |>
  map (fun ty -> ty, fix_identifier @@ string_of_type ty);;

(* set_extra db Extra_memo ["size_list"];; *)
generate_call_counters := true;;


needs "out.hl";;
compile_term db "t" `pred_list (\x. x <= 10) [1;2;4;3]` |> print_expr Format.std_formatter;;
compile_term db "t" `map_filter (\x. if x <= 10 then SOME (x + 2) else NONE) [1;2;4;3]` |> print_expr Format.std_formatter;;

let tm = Nat_arith.replace_numerals `Graph [] 0 [[Face [1;2] Final]; [Face [3] Nonfinal]] [1;2]`;;
let tm2 = rand (concl (f_graph `N4 _0`));;

f_is_none `NONE`;;
f_between `[1;2;3]` `1` `3`;;

f_tri `Graph [] 0 [[Face [1;2] Final]; [Face [3] Nonfinal]] [1;2]` `1`;;
f_facesAt tm `1`;;
f_degree tm2 `1`;;
f_except tm2 `1`;;
f_finals tm2;;
f_heights tm;;
f_height tm `1`;;
f_nextElem `[1;2;3]` `0` `2`;;
f_setFinal `Face [1;2] Nonfinal`;;
f_nextVertex `Face [1;2;3;4] Final` `4`;;
f_neighbors tm2 `2`;;
f_nonFinals tm2;;
f_vertextype tm2 `1`;;
f_finalVertex tm2 `0`;;
f_final_graph tm2;;
f_nextVertices `Face [1;2;3;4] Nonfinal` `3` `2`;;
f_countVertices tm2;;
f_directedLength `Face [1;2;3;4] Nonfinal` `1` `2`;;
f_vertices_graph tm2;;
f_tame10 tm;;
f_tame11a tm2;;
f_tame11b tm2;;
f_tame12o tm2;;
f_tame10ub tm2;;
f_excessTCount;;
f_squanderTarget;;
f_squanderFace `1`;;
f_squanderVertex `1` `20`;;
f_maxGon `3`;;
f_seed `0`;;
f_duplicateEdge tm2 `Face [1;2] Nonfinal` `1` `2`;;
f_containsUnacceptableEdgeSnd (`>`, f_GT) `1` `[1;2;3;4;5]`;;
f_containsUnacceptableEdge (`<=`, f_LE) `[1;2;3;4]`;;
f_containsDuplicateEdge tm2 `Face [1;2] Nonfinal` `1` `[1;2;3]`;;

let trie = `Tries [0] [1, Tries [1;2] []; 2, Tries [4] []]`;;
type_of trie;;
f_alist trie;;
f_values trie;;
f_lookup trie `[2]`;;
f_rem_alist `1` `[2,2;5,3;1,1;3,4]`;;
f_update trie `[1]` `[2;5]`;;

f_minimalFace `[Face [1;2] Final; Face [2;3;4] Nonfinal; Face [1] Final]`;;
f_minimalVertex tm2 `Face [1;2;3] Final`;;
f_listSum `[1;2;3]` (`SUC`, f_SUC);;
f_heightsNewVertices `1` `4` `4`;;
f_replacefacesAt `[1;2;3]` `1` `[1]` `[[2]]`;;
f_split_face `Face [1;2;3;4] Final` `2` `4` `[5;6]`;;
f_splitFace tm2 `1` `2` `Face [1;2;3] Nonfinal` `[1;2]`;;
f_makeFaceFinalFaceList `Face [1;2;3] Final` `[Face [1;2;3] Nonfinal]`;;
f_makeFaceFinal `Face [3] Nonfinal` tm;;
f_subdivFace tm2 `Face [3;2;1;0] Nonfinal` `[SOME 1; NONE; SOME 3]`;;

f_enumAppend `5` `[[1; 2; 3; 2]; [0]]`;;
f_enumerator `5` `7`;;
f_enum `5` `7`;;

f_hideDups `[1;2;3;3;3;4;3]`;;
f_indexToVertexList `Face [1;2;3] Nonfinal` `2` `[1;2;0;0]`;;
f_notame tm2;;
f_excessAtType `2` `4` `0`;;
f_excessAt tm2 `3`;;
f_faceSquanderLowerBound tm2;;
f_deleteAround tm2 `1` `[1,2; 0,3]`;;

f_excessNotAtRec `[1,2; 3,4]` tm2;;
f_excessTable tm `[0;1]`;;
f_excessNotAt tm `SOME 0`;;
f_squanderLowerBound tm2;;
f_polysizes `1` tm2;;
f_is_tame13a tm2;;
f_generatePolygonTame `1` `0` `Face [1;2] Final` tm;;
f_next_tame0 `2` tm2;;
f_is_tame tm2;;
f_next_tame `0` tm2;;
f_nof_vertices `[[1;2]; [3]; [0;1]]`;;

f_qsort (`>`, f_GT) `[1;0;3;2;4;1]`;;
f_hash `[[1;2;3]; [1]; [2;3;4]]`;;
f_fgraph tm2;;
f_merge `[1,2; 5,1]` `[3,4; 1,3]`;;
f_compat `[1,2; 5,1]` `[5,4; 1,3]`;;

f_pr_iso_test `[[1;2];[3]]` `[[2;1];[2]]`;;
f_iso_test `[[1;2];[2]]` `[[2;1];[2]]`;;

let trie = `Tries [[[0]]] [1, Tries [[[1;2]]] []; 2, Tries [[[4]]] []]`;;
f_insert_mod_trie `[[1]]` trie;;

f_tameEnumFilter;;

let const_names = 
  List.map (fun (n, th, _) ->
    let th0 = hd (BODY_CONJUNCTS th) in
    let const, _ = strip_comb (lhand (concl th0)) in
    let name, _ = dest_const const in
    name) rules;;

let () =
  set_extra_for_all db Extra_counter;
  set_rule db `(=):A->A->bool`;
  write_rules_names db "out.hl" const_names;;
loadt "out.hl";;
