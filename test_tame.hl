(* load_path := "/Users/monad/Work/git/formal_ineqs" :: !load_path;; *)
needs "tame_defs.hl";;
needs "tame_defs_unrolled.hl";;
loadt "test_tame_support.hl";;

let rules = [
  "APPEND_UNROLL8", APPEND_UNROLL8, [
    `APPEND:(num)list->(num)list->(num)list`;
    `APPEND:(face)list->(face)list->(face)list`;
    `APPEND:((face)list)list->((face)list)list->((face)list)list`;
    `APPEND:((num)list)list->((num)list)list->((num)list)list`;
    `APPEND:(graph)list->(graph)list->(graph)list`
  ];
  "map_of_DEF", map_of_DEF, [
    `map_of:(num#(num,((num)list)list)tries)list->num->((num,((num)list)list)tries)option`
  ];
  "the_DEF", the_DEF, [
    `the:(num)option->num`;
    `the:(num#num)option->num#num`;
    `the:((num,((num)list)list)tries)option->(num,((num)list)list)tries`;
    `the:((real)list#(num,((num)list)list)tries)option->(real)list#(num,((num)list)list)tries`;
  ];
  "is_none_DEF", is_none_DEF, [
    `is_none:(num)option->bool`;
    `is_none:(num#num)option->bool`;
    `is_none:((num,((num)list)list)tries)option->bool`;
    `is_none:((real)list#(num,((num)list)list)tries)option->bool`;
  ];
  "funpow_UNROLL5", funpow_UNROLL5, [
    `funpow:num->(num->num)->num->num`;
    `funpow:num->(((num)list)list->((num)list)list)->((num)list)list->((num)list)list`;
  ];
  "nth_UNROLL15", nth_UNROLL15, [
    `nth:((face)list)list->num->(face)list`;
    `nth:(num)list->num->num`;
  ];
  "fold_DEF", fold_DEF, [
    `fold:(num->(num)list->(num)list)->(num)list->(num)list->(num)list`;
  ];
  "rev_DEF", rev_DEF, [
    `rev:(num)list->(num)list`;
  ];
  "upt_DEF", upt_DEF, [];
  "zip_ALT", zip_ALT, [
    `zip:(num)list->(num)list->(num#num)list`;
  ];
  "null_DEF", null_DEF, [
    `null:(face)list->bool`;
    `null:(num)list->bool`;
    `null:((num)list)list->bool`;
  ];
  "last_DEF", last_DEF, [
    `last:(num)list->num`;
  ];
  "maps_UNROLL7", maps_UNROLL7, [
    `maps:((num)list->((num)list)list)->((num)list)list->((num)list)list`;
    `maps:(face->(num)list)->(face)list->(num)list`;
    `maps:(num->(graph)list)->(num)list->(graph)list`
  ];
  "foldl_DEF", foldl_DEF, [
    `foldl:(num->num->num)->num->(num)list->num`;
  ];
  "foldr_ALT", foldr_ALT, [
    `foldr:((num)list->(num)list->(num)list)->((num)list)list->(num)list->(num)list`
  ];
  "concat_DEF", concat_DEF, [
    `concat:((num)list)list->(num)list`
  ];
  "filter_DEF", filter_DEF, [
    `filter:(face->bool)->(face)list->(face)list`;
    `filter:(num#num->bool)->(num#num)list->(num#num)list`;
    `filter:(num->bool)->(num)list->(num)list`;
    `filter:((num)list->bool)->((num)list)list->((num)list)list`;
    `filter:(graph->bool)->(graph)list->(graph)list`;
  ];
  "member_DEF", member_DEF, [
    `member:(num)list->num->bool`
  ];
  "rotate1_DEF", rotate1_DEF, [
    `rotate1:(num)list->(num)list`
  ];
  "rotate_ALT", rotate_ALT, [
    `rotate:num->(num)list->(num)list`
  ];
  "bool_to_num_DEF", bool_to_num_DEF, [];
  "count_UNROLL7", count_UNROLL7, [
    `count:(face->bool)->(face)list->num`;
  ];
  "hd_DEF", hd_DEF, [
    `hd:((num)option)list->(num)option`;
  ];
  "tl_DEF", tl_DEF, [
    `tl:((num)option)list->((num)option)list`;
  ];
  "list_ex_DEF", list_ex_DEF, [
    `list_ex:((num)list->bool)->((num)list)list->bool`;
    `list_ex:(((num)list)list->bool)->(((num)list)list)list->bool`;
  ];
  "remdups_DEF", remdups_DEF, [
    `remdups:(num)list->(num)list`
  ];
  "remove1_DEF", remove1_DEF, [
    `remove1:(num)list->((num)list)list->((num)list)list`;
  ];
  "map_UNROLL11", map_UNROLL11, [
    `map:(face->num)->(face)list->(num)list`;
    `map:(num->num)->(num)list->(num)list`;
    `map:((face)list->(face)list)->((face)list)list->((face)list)list`;
    `map:(num->(num)list)->(num)list->((num)list)list`;
    `map:((num)list->(num)list)->((num)list)list->((num)list)list`;
    `map:((num)list->((num)option)list)->((num)list)list->(((num)option)list)list`;
    `map:(((num)option)list->graph)->(((num)option)list)list->(graph)list`;
    `map:(face->(num)list)->(face)list->((num)list)list`;
  ];
  "pred_list_UNROLL11", pred_list_UNROLL11, [
    `pred_list:(face->bool)->(face)list->bool`;
    `pred_list:(num->bool)->(num)list->bool`;
    `pred_list:(num#num->bool)->(num#num)list->bool`;
  ];
  "replicate_DEF", replicate_DEF, [
    `replicate:num->(face)list->((face)list)list`;
    `replicate:num->num->(num)list`;
  ];
  "gen_length_DEF", gen_length_DEF, [
    `gen_length:num->(num)list->num`;
    `gen_length:num->(face)list->num`;
    `gen_length:num->((face)list)list->num`;
    `gen_length:num->((num)list)list->num`;
  ];
  "map_filter_ALT", map_filter_ALT, [
    `map_filter:(num->(num#num)option)->(num)list->(num#num)list`;
    `map_filter:((num)list->(num)option)->((num)list)list->(num)list`;
  ];
  "list_update_DEF", list_update_DEF, [
    `list_update:((face)list)list->num->(face)list->((face)list)list`;
  ];
  "all_interval_nat_DEF", all_interval_nat_DEF, [];
  (* "size_list_DEF", size_list_DEF; *)
  "size_list_UNROLL15", size_list_UNROLL15, [
    `size_list:(num)list->num`;
    `size_list:(face)list->num`;
    `size_list:((face)list)list->num`;
    `size_list:((num)list)list->num`;
  ];
  "fst_DEF", fst_DEF, [
    `fst:num#(num,((num)list)list)tries->num`;
    `fst:num#num->num`;
  ];
  "snd_DEF", snd_DEF, [
    `snd:(real)list#(num,((num)list)list)tries->(num,((num)list)list)tries`;
  ];
  "mapAt_DEF", mapAt_DEF, [
    `mapAt:(num)list->((face)list->(face)list)->((face)list)list->((face)list)list`;
  ];
  "splitAtRec_DEF", splitAtRec_DEF, [
    `splitAtRec:num->(num)list->(num)list->(num)list#(num)list`
  ];
  "splitAt_DEF", splitAt_DEF, [
    `splitAt:num->(num)list->(num)list#(num)list`
  ];
  "between_ALT", between_ALT, [
    `between:(num)list->num->num->(num)list`
  ];
  "minimall_ALT", minimall_ALT, [
    `minimall:(face->num)->(face)list->face`;
    `minimall:(num->num)->(num)list->num`;
  ];
  "replace_DEF", replace_DEF, [
    `replace:face->(face)list->(face)list->(face)list`;
  ];
  "removeKey_DEF", removeKey_DEF, [
    `removeKey:num->(num#num)list->(num#num)list`;
  ];
  "removeKeyList_DEF", removeKeyList_DEF, [
    `removeKeyList:(num)list->(num#num)list->(num#num)list`;
  ];

  "vertices_face_DEF", vertices_face_DEF, [];
  "final_face_DEF", final_face_DEF, [];
  "faceListAt_DEF", faceListAt_DEF, [];
  "facesAt_DEF", facesAt_DEF, [];
  "tri_ALT", tri_ALT, [];
  "quad_ALT", quad_ALT, [];
  "faces_DEF", faces_DEF, [];
  "graph_ALT", graph_ALT, [];
  "degree_DEF", degree_DEF, [];
  "except_ALT", except_ALT, [];
  "finals_DEF", finals_DEF, [];
  "heights_DEF", heights_DEF, [];
  "height_DEF", height_DEF, [];
  "nextElem_ALT", nextElem_ALT, [
    `nextElem:(num)list->num->num->num`;
  ];
  "setFinal_DEF", setFinal_DEF, [];
  "nextVertex_ALT", nextVertex_ALT, [];
  "neighbors_DEF", neighbors_DEF, [];
  "nonFinals_DEF", nonFinals_DEF, [];
  "vertextype_DEF", vertextype_DEF, [];
  "finalVertex_DEF", finalVertex_DEF, [];
  "final_graph_ALT", final_graph_ALT, [];
  "nextVertices_DEF", nextVertices_DEF, [];
  "countVertices_DEF", countVertices_DEF, [];
  "directedLength_DEF", directedLength_DEF, [];
  "vertices_graph_DEF", vertices_graph_DEF, [];

  "tame10_ALT", tame10_ALT, [];
  "tame11a_DEF", tame11a_DEF, [];
  "tame11b_DEF", tame11b_DEF, [];
  "tame12o_ALT", tame12o_ALT, [];
  "tame10ub_DEF", tame10ub_DEF, [];
  "excessTCount_DEF", excessTCount_DEF, [];
  "squanderTarget_DEF", squanderTarget_DEF, [];
  "squanderFace_ALT", squanderFace_ALT, [];
  "squanderVertex_ALT2", squanderVertex_ALT2, [];
  "maxGon_DEF", maxGon_DEF, [];
  "seed_DEF", seed_DEF, [];
  "duplicateEdge_DEF", duplicateEdge_DEF, [];
  "containsUnacceptableEdgeSnd_ALT", containsUnacceptableEdgeSnd_ALT, [];
  "containsUnacceptableEdge_ALT", containsUnacceptableEdge_ALT, [];
  "containsDuplicateEdge_DEF", containsDuplicateEdge_DEF, [];

  "alist_DEF", alist_DEF, [
    `alist:(num,((num)list)list)tries->(num#(num,((num)list)list)tries)list`
  ];
  "values_DEF", values_DEF, [
    `values:(num,((num)list)list)tries->(((num)list)list)list`
  ];
  "lookup_ALT", lookup_ALT, [
    `lookup:(num,((num)list)list)tries->(num)list->(((num)list)list)list`
  ];
  "rem_alist_DEF", rem_alist_DEF, [
    `rem_alist:num->(num#(num,((num)list)list)tries)list->(num#(num,((num)list)list)tries)list`
  ];
  "update_ALT", update_ALT, [
    `update:(num,((num)list)list)tries->(num)list->(((num)list)list)list->(num,((num)list)list)tries`
  ];

  "minimalFace_ALT", minimalFace_ALT, [];
  "minimalVertex_DEF", minimalVertex_DEF, [];
  "listSum_DEF", listSum_DEF, [
    `listSum:(face)list->(face->num)->num`;
  ];
  "heightsNewVertices_DEF", heightsNewVertices_DEF, [];
  "replacefacesAt_DEF", replacefacesAt_DEF, [
    `replacefacesAt:(num)list->face->(face)list->((face)list)list->((face)list)list`
  ];
  "split_face_ALT", split_face_ALT, [];
  "splitFace_ALT", splitFace_ALT, [];
  "makeFaceFinalFaceList_DEF", makeFaceFinalFaceList_DEF, [];
  "makeFaceFinal_DEF", makeFaceFinal_DEF, [];
  "subdivFacea_ALT", subdivFacea_ALT, [];
  "subdivFace_DEF", subdivFace_DEF, [];

  "enumAppend_DEF", enumAppend_DEF, [];
  "enumBase_DEF", enumBase_DEF, [];
  "enumerator_ALT", enumerator_ALT, [];
  "enum_ALT", enum_ALT, [];

  "hideDupsRec_DEF", hideDupsRec_DEF, [
    `hideDupsRec:num->(num)list->((num)option)list`;
  ];
  "hideDups_DEF", hideDups_DEF, [
    `hideDups:(num)list->((num)option)list`;
  ];
  "indexToVertexList_DEF", indexToVertexList_DEF, [];
  "notame_DEF", notame_DEF, [];
  "excessAtType_ALT", excessAtType_ALT, [];
  "excessAt_DEF", excessAt_DEF, [];
  "faceSquanderLowerBound_DEF", faceSquanderLowerBound_DEF, [];
  "deleteAround_ALT", deleteAround_ALT, [
    `deleteAround:graph->num->(num#num)list->(num#num)list`
  ];
  
  "excessNotAtRec_ALT", excessNotAtRec_ALT, [];
  "excessTable_ALT", excessTable_ALT, [];
  "excessNotAt_ALT", excessNotAt_ALT, [];
  "squanderLowerBound_DEF", squanderLowerBound_DEF, [];
  "polysizes_ALT", polysizes_ALT, [];
  "is_tame13a_ALT", is_tame13a_ALT, [];
  "generatePolygonTame_ALT", generatePolygonTame_ALT, [];
  "next_tame0_ALT", next_tame0_ALT, [];
  "is_tame_DEF", is_tame_DEF, [];
  "next_tame_ALT", next_tame_ALT, [];
  "worklist_tree_aux_DEF", worklist_tree_aux_DEF, [
    `worklist_tree_aux:(graph->(graph)list)->(graph->(num,((num)list)list)tries->(num,((num)list)list)tries)->(graph)list#(num,((num)list)list)tries->((real)list#(num,((num)list)list)tries)option`
  ];
  "worklist_tree_ALT", worklist_tree_ALT, [
    `worklist_tree:(graph->(graph)list)->(graph->(num,((num)list)list)tries->(num,((num)list)list)tries)->(graph)list->(num,((num)list)list)tries->((num,((num)list)list)tries)option`
  ];
  "nof_vertices_ALT", nof_vertices_ALT, [
    `nof_vertices:((num)list)list->num`
  ];

  "qsort_DEF", qsort_DEF, [`qsort:(num->num->bool)->(num)list->(num)list`];
  "hash_ALT", hash_ALT, [];
  "fgraph_DEF", fgraph_DEF, [];
  "merge_ALT", merge_ALT, [
    `merge:(num#num)list->(num#num)list->(num#num)list`;
  ];
  "compat_DEF", compat_DEF, [
    `compat:(num#num)list->(num#num)list->bool`;
  ];

  "pr_iso_test_rec_ALT", pr_iso_test_rec_ALT, [
    `pr_iso_test_rec:(num#num)list->((num)list)list->((num)list)list->bool`
  ];
  "pr_iso_test_DEF", pr_iso_test_DEF, [
    `pr_iso_test:((num)list)list->((num)list)list->bool`
  ];
  "iso_test_DEF", iso_test_DEF, [
    `iso_test:((num)list)list->((num)list)list->bool`
  ];
  "insert_mod_trie_ALT", insert_mod_trie_ALT, [];
  (* "insert_mod2_trie_DEF", insert_mod2_trie_DEF;
  "worklist_tree_coll_aux_trie_ALT", worklist_tree_coll_aux_trie_ALT;
  "worklist_tree_coll_trie_DEF", worklist_tree_coll_trie_DEF;
  "enum_filter_finals_ALT", enum_filter_finals_ALT; *)
  "tameEnumFilter_ALT", tameEnumFilter_ALT, [];

  "worklist_tree_bounded_ALT", worklist_tree_bounded_ALT, [
    `worklist_tree_bounded:num->(graph->(graph)list)->(graph->(num,((num)list)list)tries->(num,((num)list)list)tries)->(graph)list->(num,((num)list)list)tries->(num,((num)list)list)tries`
  ];
  "tameEnumFilterBounded_DEF", tameEnumFilterBounded_DEF, [];
];;

let const_names = 
  List.map (fun (n, th, _) ->
    let th0 = hd (BODY_CONJUNCTS th) in
    let const, _ = strip_comb (lhand (concl th0)) in
    let name, _ = dest_const const in
    name) rules;;

let db = add_thms (tame_default_db ()) rules;;
set_extra_for_consts db Extra_memo [
  (* `bool_to_num`; *)
  `squanderFace`;
  `maxGon`;
  (* `fst:num#num->num`; *)
  (* `is_none:(num#num)option->bool`; *)
  (* `final_face`; *)
  `size_list:(num)list->num`;
  `excessAtType`;
  `squanderVertex`;
  `vertices_face`;
  `heightsNewVertices`;
  `upt`;
  (* `nextElem:(num)list->num->num->num`; *)
  `nextVertex`;
  `rev:(num)list->(num)list`;
  `APPEND:(num)list->(num)list->(num)list`;
  `nextVertices`;
  `member:(num)list->num->bool`;
  `enum`;
  (* `nth:(num)list->num->num`; *)
  (* `faceListAt`; *)
  `splitAtRec:num->(num)list->(num)list->(num)list#(num)list`;
  `map:(num->(num)list)->(num)list->((num)list)list`;
  `map:((num)list->(num)list)->((num)list)list->((num)list)list`;
  (* `filter:(num#num->bool)->(num#num)list->(num#num)list`; *)
  `removeKeyList:(num)list->(num#num)list->(num#num)list`;
  (* `nth:((face)list)list->num->(face)list`; *)
  (* `excessNotAtRec`; *)
];;

let () =
  set_extra_for_names db Extra_counter const_names;
  (* set_extra_for_names db Extra_arg_list const_names; *)
  write_rules_names db "out.hl" const_names;;
loadt "out.hl";;

(* 40.714s *)
(* original: 0.0171s *)
(* ratio: 2381 *)

(* 26.144s with COND instead of AND/OR *)
(* 25.406s with new AND/OR *)
(* 23.614s with size_list_ALT with 15 cases *)
(* 18.631s with custom types (COND, f_EQ still use INST_TYPE) *)
(* 17.927s with custom types (including COND but without f_EQ) *)
(* 17.995s with custom types everywhere *)
(* 14.663s with nth_ALT with 10 cases *)
(* 14.538s with funpow_ALT2 with 5 cases *)
(* 14.487s with maps_ALT, count_ALT, map_ALT, pred_list_ALT *)
(* 9.915s with fast arithmetic *)
(* 9.859s with fast arithmetic + standardize *)
(* 9.797s with APPEND_UNROLL8 *)
(* 9.653s with nth_UNROLL15, maps_UNROLL7, count_UNROLL7 *)
(* 8.962s with memos *)
reset_all_counters();;
(* reset_core_counters();; *)
clear_arg_lists();;
clear_all_memos();;
test 1 (f_tameEnumFilterBounded (numeral `0`)) (numeral `100`);;
test 1 (f_tameEnumFilterBounded `0`) `100`;;

(* New orda improves performance *)
(* type_of 5566376 *)
(* type_of 2913467 with new MK_COMB *)
(* No significant difference in performance *)
core_counters();;
reset_core_counters();;

time (f_tameEnumFilterBounded `0`) `100000`;;
setify_types !eq_types;;

get_all_counters();;
get_counter "f_gen_length";;
Hashtbl.fold (fun k v r -> k :: r) (create_memo "f_size_list") [];;

(* nth -> unroll up to 15 *)
(* maps -> up to 7 *)
(* count -> up to 7 *)

analyze_arg_lists();;

let args = lazy !(create_arg_list "f_squanderVertex");;
let n = Lazy.force args |> length;;
Lazy.force args |> map (length o dest_list o el 0) |> freqs;;
Lazy.force args |> map (Nat_arith.dest_nat o el 0) |> freqs;;
Lazy.force args |> freqs;;
let t = Lazy.force args |> freqs |> length;;
float (n - t) /. float n;;

Nat_arith.reset_cache();;

setify !cond_types |>
  map (fun ty -> ty, fix_identifier @@ string_of_type ty);;

(* set_extra db Extra_memo ["size_list"];; *)
generate_call_counters := true;;


needs "out.hl";;
compile_term db "t" `pred_list (\x. x <= 10) [1;2;4;3]` |> print_expr Format.std_formatter;;
compile_term db "t" `map_filter (\x. if x <= 10 then SOME (x + 2) else NONE) [1;2;4;3]` |> print_expr Format.std_formatter;;

let tm = Nat_arith.replace_numerals `Graph [] 0 [[Face [1;2] Final]; [Face [3] Nonfinal]] [1;2]`;;
let tm2 = rand (concl (f_graph `N4 _0`));;

f_is_none `NONE`;;
f_between `[1;2;3]` `1` `3`;;

f_tri `Graph [] 0 [[Face [1;2] Final]; [Face [3] Nonfinal]] [1;2]` `1`;;
f_facesAt tm `1`;;
f_degree tm2 `1`;;
f_except tm2 `1`;;
f_finals tm2;;
f_heights tm;;
f_height tm `1`;;
f_nextElem `[1;2;3]` `0` `2`;;
f_setFinal `Face [1;2] Nonfinal`;;
f_nextVertex `Face [1;2;3;4] Final` `4`;;
f_neighbors tm2 `2`;;
f_nonFinals tm2;;
f_vertextype tm2 `1`;;
f_finalVertex tm2 `0`;;
f_final_graph tm2;;
f_nextVertices `Face [1;2;3;4] Nonfinal` `3` `2`;;
f_countVertices tm2;;
f_directedLength `Face [1;2;3;4] Nonfinal` `1` `2`;;
f_vertices_graph tm2;;
f_tame10 tm;;
f_tame11a tm2;;
f_tame11b tm2;;
f_tame12o tm2;;
f_tame10ub tm2;;
f_excessTCount;;
f_squanderTarget;;
f_squanderFace `1`;;
f_squanderVertex `1` `20`;;
f_maxGon `3`;;
f_seed `0`;;
f_duplicateEdge tm2 `Face [1;2] Nonfinal` `1` `2`;;
f_containsUnacceptableEdgeSnd (`>`, f_GT) `1` `[1;2;3;4;5]`;;
f_containsUnacceptableEdge (`<=`, f_LE) `[1;2;3;4]`;;
f_containsDuplicateEdge tm2 `Face [1;2] Nonfinal` `1` `[1;2;3]`;;

let trie = `Tries [0] [1, Tries [1;2] []; 2, Tries [4] []]`;;
type_of trie;;
f_alist trie;;
f_values trie;;
f_lookup trie `[2]`;;
f_rem_alist `1` `[2,2;5,3;1,1;3,4]`;;
f_update trie `[1]` `[2;5]`;;

f_minimalFace `[Face [1;2] Final; Face [2;3;4] Nonfinal; Face [1] Final]`;;
f_minimalVertex tm2 `Face [1;2;3] Final`;;
f_listSum `[1;2;3]` (`SUC`, f_SUC);;
f_heightsNewVertices `1` `4` `4`;;
f_replacefacesAt `[1;2;3]` `1` `[1]` `[[2]]`;;
f_split_face `Face [1;2;3;4] Final` `2` `4` `[5;6]`;;
f_splitFace tm2 `1` `2` `Face [1;2;3] Nonfinal` `[1;2]`;;
f_makeFaceFinalFaceList `Face [1;2;3] Final` `[Face [1;2;3] Nonfinal]`;;
f_makeFaceFinal `Face [3] Nonfinal` tm;;
f_subdivFace tm2 `Face [3;2;1;0] Nonfinal` `[SOME 1; NONE; SOME 3]`;;

f_enumAppend `5` `[[1; 2; 3; 2]; [0]]`;;
f_enumerator `5` `7`;;
f_enum `5` `7`;;

f_hideDups `[1;2;3;3;3;4;3]`;;
f_indexToVertexList `Face [1;2;3] Nonfinal` `2` `[1;2;0;0]`;;
f_notame tm2;;
f_excessAtType `2` `4` `0`;;
f_excessAt tm2 `3`;;
f_faceSquanderLowerBound tm2;;
f_deleteAround tm2 `1` `[1,2; 0,3]`;;

f_excessNotAtRec `[1,2; 3,4]` tm2;;
f_excessTable tm `[0;1]`;;
f_excessNotAt tm `SOME 0`;;
f_squanderLowerBound tm2;;
f_polysizes `1` tm2;;
f_is_tame13a tm2;;
f_generatePolygonTame `1` `0` `Face [1;2] Final` tm;;
f_next_tame0 `2` tm2;;
f_is_tame tm2;;
f_next_tame `0` tm2;;
f_nof_vertices `[[1;2]; [3]; [0;1]]`;;

f_qsort (`>`, f_GT) `[1;0;3;2;4;1]`;;
f_hash `[[1;2;3]; [1]; [2;3;4]]`;;
f_fgraph tm2;;
f_merge `[1,2; 5,1]` `[3,4; 1,3]`;;
f_compat `[1,2; 5,1]` `[5,4; 1,3]`;;

f_pr_iso_test `[[1;2];[3]]` `[[2;1];[2]]`;;
f_iso_test `[[1;2];[2]]` `[[2;1];[2]]`;;

let trie = `Tries [[[0]]] [1, Tries [[[1;2]]] []; 2, Tries [[[4]]] []]`;;
f_insert_mod_trie `[[1]]` trie;;

f_tameEnumFilter;;
