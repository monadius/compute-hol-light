type expr =
  | Match of expr * (expr * expr) list
  | Try of expr * (expr * expr) list
  | Lambda of expr list * expr
  | Tuple of expr list
  | List_expr of expr list
  | Let of bool * string * expr list * expr * expr option
  | Let_and of expr list * expr option
  | If of expr * expr * expr
  | App of expr * expr
  | Term of term
  | String of string
  | Raw of string;;

let is_app = function App _ -> true | _ -> false;;

let is_let = function Let _ -> true | _ -> false;;

let is_match = function Match _ -> true | _ -> false;;

let is_compound = function
  | Let _ | Let_and _ | Match _ | Try _ | Lambda _ -> true
  | _ -> false;;

let mk_app (head, args) =
  List.fold_left (fun e a -> App (e, a)) head args;;

let mk_raw s = Raw s;;

let mk_tuple = function
  | [] -> Raw "()"
  | [e] -> e
  | es -> Tuple es;;

let mk_list_expr exprs = List_expr exprs;;

let mk_int_list ints = mk_list_expr (List.map (fun i -> mk_raw (string_of_int i)) ints);;

let mk_let_and ?(body = None) = function
  | [] -> failwith "mk_let_and: empty list"
  | exprs when forall is_let exprs -> Let_and (exprs, body)
  | _ -> failwith "mk_let_and: all expressions must be let-expressions";;

let mk_let ?(args = []) ?(body = None) (name, expr) =
  Let (false, name, args, expr, body);;

let rec chain_let = function
  | [e] -> e
  | Let (r, a, b, e, _) :: es ->
    Let (r, a, b, e, Some (chain_let es))
  | Let_and (exprs, _) :: es ->
    Let_and (exprs, Some (chain_let es))
  | _ -> failwith "chain_let";;

let rec append_let_body let_e body =
  match let_e with
  | Let_and (exprs, None) -> Let_and (exprs, Some body)
  | Let_and (exprs, Some n) -> Let_and (exprs, Some (append_let_body n body))
  | Let (r, a, b, e, None) -> Let (r, a, b, e, Some body)
  | Let (r, a, b, e, Some n) -> Let (r, a, b, e, Some (append_let_body n body))
  | _ -> failwith "append_let_body";;

let print_expr =
  let let_form and_flag rec_flag =
    match and_flag, rec_flag with
    | true, _ -> "and"
    | _, true -> "let rec"
    | _ -> "let" in
  let rec print_args fmt =
    Format.pp_print_list ~pp_sep:(fun fmt () -> Format.pp_print_string fmt " ") print_expr fmt
  and print_let and_flag fmt = function
    | Let (r, name, args, expr, None) ->
      Format.fprintf fmt "@[<v 2>%s %s %a%s=@ %a@]@ "
        (let_form and_flag r) name 
        print_args args (if args = [] then "" else " ")
        print_expr expr
    | Let (r, name, args, expr, Some body) ->
      let f = format_of_string 
        (if is_compound expr then
          "@[<v 2>let%s %s %a%s=@ %a in@]@ %a"
        else
          "@[<hv 2>let%s %s %a%s=@ %a in@]@ %a") in
      Format.fprintf fmt f
          (if r then " rec" else "") name
          print_args args (if args = [] then "" else " ")
          print_expr expr print_expr body
    | _ -> failwith "print_let: Let expected"
  and print_expr fmt = function
  | Raw s -> Format.fprintf fmt "%s" s
  | String s -> Format.fprintf fmt "\"%s\"" s
  | Term tm -> 
    Format.fprintf fmt "`(%s):%s`" 
      (string_of_term tm) (string_of_type (type_of tm))
  | Tuple es -> 
    Format.fprintf fmt "(%a)" 
      (Format.pp_print_list 
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt ", ")
        print_expr) es
  | List_expr es ->
    Format.fprintf fmt "[%a]"
      (Format.pp_print_list
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt "; ")
        print_expr) es
  | Lambda (args, body) ->
    Format.fprintf fmt "@[<v 2>fun %a ->@,%a@]"
      print_args args print_expr body
  | If (c, t, e) ->
    Format.fprintf fmt "@[<v 2>if %a then@ %a@;<1 -2>else@ %a@]"
      print_expr c print_expr t print_expr e
  | App (f, x) ->
    let f1 = format_of_string "%a" in
    let f2 = format_of_string (if is_app x then " (%a)" else " %a") in
    Format.fprintf fmt (f1 ^^ f2) print_expr f print_expr x
  | Let _ as expr -> print_let false fmt expr
  | Let_and (expr1 :: exprs, None) ->
    Format.fprintf fmt "@[<v>%a%a@]"
      (print_let false) expr1
      (Format.pp_print_list ~pp_sep:(fun fmt () -> ()) (print_let true)) exprs
  | Let_and (expr1 :: exprs, Some body) ->
    Format.fprintf fmt "@[<v>%a%a in@]@ %a"
      (print_let false) expr1
      (Format.pp_print_list ~pp_sep:(fun fmt () -> ()) (print_let true)) exprs
      print_expr body
  | Let_and _ -> failwith "Let_and: empty list"
  | Try (expr, cases) ->
    Format.fprintf fmt "@[<v 2>try@ %a@]@ with@,| %a"
      print_expr expr
      (Format.pp_print_list 
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt "| ")
        (fun fmt (pat, body) ->
          let f = format_of_string 
            (if is_compound body then
              "@[<v>%a ->@ %a@]@,"
             else
              "@[<hv>%a ->@ %a@]@,") in
          Format.fprintf fmt f
            print_expr pat print_expr body)) cases
  | Match (expr, cases) ->
    Format.fprintf fmt "match %a with@,| %a"
      print_expr expr
      (Format.pp_print_list 
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt "| ")
        (fun fmt (pat, body) ->
          let f = format_of_string 
            (if is_compound body then
              "@[<v>%a ->@ %a@]@,"
             else
              "@[<hv>%a ->@ %a@]@,") in
          Format.fprintf fmt f
            print_expr pat print_expr body)) cases in
  print_expr;;
