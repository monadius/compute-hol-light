needs "eval_compile.hl";;

let f_EQ_num =
  let const = `(=):num->num->bool` in
  fun a b opt -> trans_opt opt (NUM_EQ_CONV (list_mk_comb (const, [a; b])));;

let f_SUC =
  let const = `SUC` in
  fun a opt -> trans_opt opt (NUM_SUC_CONV (mk_comb (const, a)));;

let f_PRE =
  let const = `PRE` in
  fun a opt -> trans_opt opt (NUM_PRE_CONV (mk_comb (const, a)));;

let f_ADD =
  let const = `+` in
  fun a b opt -> trans_opt opt (NUM_ADD_CONV (list_mk_comb (const, [a; b])));;

let f_SUB =
  let const = `-` in
  fun a b opt -> trans_opt opt (NUM_SUB_CONV (list_mk_comb (const, [a; b])));;

let f_MUL =
  let const = `*` in
  fun a b opt -> trans_opt opt (NUM_MULT_CONV (list_mk_comb (const, [a; b])));;

let f_EXP =
  let const = `EXP` in
  fun a b opt -> trans_opt opt (NUM_EXP_CONV (list_mk_comb (const, [a; b])));;

let f_DIV =
  let const = `DIV` in
  fun a b opt -> trans_opt opt (NUM_DIV_CONV (list_mk_comb (const, [a; b])));;

let f_MOD =
  let const = `MOD` in
  fun a b opt -> trans_opt opt (NUM_MOD_CONV (list_mk_comb (const, [a; b])));;

let f_FACT =
  let const = `FACT` in
  fun a opt -> trans_opt opt (NUM_FACT_CONV (mk_comb (const, a)));;

let f_LE =
  let const = `<=` in
  fun a b opt -> trans_opt opt (NUM_LE_CONV (list_mk_comb (const, [a; b])));;

let f_LT =
  let const = `<` in
  fun a b opt -> trans_opt opt (NUM_LT_CONV (list_mk_comb (const, [a; b])));;

let f_GE =
  let const = `>=` in
  fun a b opt -> trans_opt opt (NUM_GE_CONV (list_mk_comb (const, [a; b])));;

let f_GT =
  let const = `>` in
  fun a b opt -> trans_opt opt (NUM_GT_CONV (list_mk_comb (const, [a; b])));;

let f_MIN =
  let const = `MIN` in
  fun a b opt -> trans_opt opt (NUM_MIN_CONV (list_mk_comb (const, [a; b])));;

let f_MAX =
  let const = `MAX` in
  fun a b opt -> trans_opt opt (NUM_MAX_CONV (list_mk_comb (const, [a; b])));;

let NOT_CLAUSES' = prove(`~T = F /\ ~F = T`, REWRITE_TAC[]);;

let LOGIC_SIMP = TAUT 
  `((A ==> B) <=> ~A \/ B) /\ 
   (~ ~A <=> A)`;;

let EQ_BOOL = prove
  (`(T = T <=> T) /\
    (F = F <=> T) /\
    (T = F <=> F) /\
    (F = T <=> F)`,
  REWRITE_TAC[]);;

let EQ_OPT = prove
  (`(opt:(A)option = opt <=> T) /\
    (NONE = SOME (x:A) <=> F) /\
    (SOME x = NONE <=> F) /\
    (SOME x = SOME y <=> x = y)`,
  REWRITE_TAC[injectivity "option"; distinctness "option"]);;

let EQ_PAIR = prove
  (`(xy:(A#B) = xy <=> T) /\
    ((x:A, y:B) = (a, b) <=> x = a /\ y = b)`,
  REWRITE_TAC[PAIR_EQ]);;

let EQ_LIST = prove
  (`(xs:(A)list = xs <=> T) /\
    ([] = CONS x xs <=> F) /\
    (CONS x xs = [] <=> F) /\
    (CONS x xs = CONS y ys <=> x = y /\ xs = ys)`,
  REWRITE_TAC[injectivity "list"; distinctness "list"]);;

let default_db name =
  let db = empty_db name in
  List.iter (fun rw -> add_extra_rewrite db rw) [
    "LET_DEF", LET_DEF;
    "LET_END_DEF", LET_END_DEF;
    "LOGIC_SIMP", LOGIC_SIMP;
  ];
  List.iter (fun c -> set_rule db c) [
    `(=):num->num->bool`;
    `SUC`; `PRE`; `+`; `-`; `*`; `EXP`; `DIV`; `MOD`; `FACT`;
    `<=`; `<`; `>=`; `>`; 
    `MIN`; `MAX`;
  ];
  add_thms db [
    "NOT_CLAUSES'", NOT_CLAUSES', [];
    "EQ_BOOL", EQ_BOOL, [];
    "EQ_OPT", EQ_OPT, [];
    "EQ_PAIR", EQ_PAIR, [];
    "EQ_LIST", EQ_LIST, [];
  ];;


