type pat = 
  | Punused
  | Pvar of term
  (* lhs, rhs, optional as clause *)
  | Pcomb of pat * pat * term option
  | Pabs of pat * term option;;

let string_of_pat names =
  let name tm = assocd tm names (string_of_term tm) in
  let rec comb_str t p1 p2 p_as =
    match p_as with
    | Some tm -> sprintf "%s (%s, %s) as %s" t (str p1) (str p2) (name tm)
    | None -> sprintf "%s (%s, %s)" t (str p1) (str p2)
  and str = function
  | Punused -> "_"
  | Pvar tm -> name tm
  | Pcomb (p1, p2, p_as) -> comb_str "Comb" p1 p2 p_as
  | Pabs (p, p_as) -> comb_str "Abs" Punused p p_as
  in
  str;;

(* Returns 1) a pattern for tm which matches terms in tms, 
           2) a list of unmatched terms in tms *)
let get_pattern =
  let rec subsets s =
    match s with
    | [] -> [[], []]
    | x :: xs ->
      let ss = subsets xs in
      List.fold_left (fun r (a, b) -> (a, x :: b) :: (x :: a, b) :: r) [] ss
  in
  let rec simplify pat =
    match pat with
    | Pvar _ | Punused -> pat
    | Pabs (p, p_as) ->
      let p' = simplify p in
      (match p', p_as with
       | Punused, None -> Punused
       | Punused, Some tm -> Pvar tm
       | _ -> Pabs (p', p_as))
    | Pcomb (p1, p2, p_as) ->
      let p1 = simplify p1 in
      let p2 = simplify p2 in
      match p1, p2, p_as with
      | Punused, Punused, None -> Punused
      | Punused, Punused, Some tm -> Pvar tm
      | _ -> Pcomb (p1, p2, p_as)
  in
  let rec complexity = function
    | Punused | Pvar _ -> 0
    | Pabs (p, _) -> complexity p + 1
    | Pcomb (p1, p2, _) -> complexity p1 + complexity p2 + 1
  in
  let rec pattern tm tms =
    match tm with
    | _ when tms = [] -> Punused, []
    | Var _ | Const _ ->
      if mem tm tms then Pvar tm, subtract tms [tm]
      else Punused, tms
    | Abs (var, btm) ->
      let p_as, tms =
        if mem tm tms then Some tm, subtract tms [tm]
        else None, tms in
      let tms' = filter (fun tm -> free_in tm btm && not (vfree_in var tm)) tms in
      let p1, _ = pattern btm tms' in
      Pabs (p1, p_as), subtract tms tms'
    | Comb (ltm, rtm) ->
      let p_as, tms =
        if mem tm tms then Some tm, subtract tms [tm]
        else None, tms in
      let ltms = filter (fun tm -> free_in tm ltm) tms and
          rtms = filter (fun tm -> free_in tm rtm) tms in
      let ctms = intersect ltms rtms in
      let ltms' = subtract ltms ctms and
          rtms' = subtract rtms ctms in
      let select_best (best, best_c) (s1, s2) =
        let p1 = pattern ltm (s1 @ ltms') |> fst |> simplify in
        let p2 = pattern rtm (s2 @ rtms') |> fst |> simplify in
        let c = complexity p1 + complexity p2 in
        if best_c < 0 || c < best_c then (p1, p2), c else best, best_c in
      let (p1, p2), _ = List.fold_left select_best ((Punused, Punused), -1) (subsets ctms) in
      Pcomb (p1, p2, p_as), subtract tms (union ltms rtms)
  in
  fun tm tms ->
    let pat, tms' = pattern tm tms in
    simplify pat, tms';;
    
      
type eval_cmd = Cmd of eval_cmd_type * eval_cmd_rec

and eval_cmd_rec = {
  result: term;
  result_type: eval_arg_type;
}

and eval_cmd_type = 
  | Cmd_ref of term
  | Cmd_app of app_type * eval_cmd list
  | Cmd_lambda of term list * eval_cmd
  | Cmd_pair of eval_cmd * eval_cmd
  | Cmd_comb of eval_cmd * eval_cmd
  | Cmd_trans of eval_cmd * eval_cmd
  | Cmd_convert of eval_arg_type * eval_arg_type * eval_cmd
  | Cmd_composite of eval_cmd list;;

let mk_cmd (t, res, res_type) = Cmd (t, { result = res; result_type = res_type });;

let mk_ref_cmd tm = mk_cmd (Cmd_ref tm, tm, Arg_term);;

let get_cmd_rec (Cmd (_, r)) = r;;

let cmd_result (Cmd (_, {result = r})) = r;;


let get_eval_commands =
  let get_type env tm =
    try assoc tm env
    with Failure _ -> 
      if is_var tm && is_fun_ty (type_of tm) then Arg_function else Arg_term 
  in
  let convert_cmd env target tm cmd =
    let ty = get_type env tm in
    if ty = target then cmd
    else
      mk_cmd (Cmd_convert (target, ty, cmd), tm, target)
  in
  let convert_ref env target tm =
    convert_cmd env target tm (mk_ref_cmd tm)
  in
  let comb env op_tm arg_tms =
    List.fold_left (fun (op, op_tm) arg_tm ->
      let arg_cmd = convert_ref env Arg_theorem arg_tm in
      let tm = mk_comb (op_tm, arg_tm) in
      mk_cmd (Cmd_comb (op, arg_cmd), tm, Arg_theorem), tm)
      (convert_ref env Arg_theorem op_tm, op_tm) arg_tms 
    |> fst
  in
  let get_extra_args env f =
    let mk_tm i ty =
      let name = string_of_int (i + 1) in
      mk_var (name, ty) in
    let tys, _ = splitlist dest_fun_ty (type_of f.app_term) in
    let extra = List.mapi mk_tm tys in
      extra, zip extra f.extra_args @ env
  in
  let rec commands env tree =
    match tree with
    | Refl _ -> env, []
    | Func_app f when can (assoc f.app_term) env -> env, []
    | Func_app f ->
      let env, cmds = 
        List.fold_left (fun (env, cmds) arg -> 
          let env', cmds' = commands env arg in
          env', cmds @ cmds') 
          (env, []) f.applied_args in
      let cmd = 
        match f.app_type with
        | Abs_app _ -> failwith "Abs_app is not allowed"
        | Basic_app op ->
          let args = map get_eval_term f.applied_args in
          let extra_args, env = get_extra_args env f in
          let cmd = comb env op (args @ extra_args) in
          if extra_args = [] then cmd
          else
            let cmd = mk_cmd (Cmd_lambda (extra_args, cmd), f.app_term, Arg_function) in
            mk_cmd (Cmd_pair (mk_ref_cmd f.app_term, cmd), f.app_term, Arg_function)
        | Const_app _ | Var_app _ ->
          let arg_tms = f.fixed_args @ map get_eval_term f.applied_args in
          let simple_app = forall (fun arg -> get_type env arg <> Arg_theorem) arg_tms in
          let extra_args, env = 
            if simple_app then [], env
            else get_extra_args env f in
          let args = map (fun tm ->
            let target = if is_fun_ty (type_of tm) then Arg_function else Arg_term in
            convert_ref env target tm) (arg_tms @ extra_args) in
          let app_cmd = mk_cmd (Cmd_app (f.app_type, args), f.app_term, Arg_theorem) in
          let cmd =
            if simple_app then app_cmd
            else
              let op, _ = strip_comb_gabs f.app_term in
              let c = comb env op arg_tms in
              let t = mk_cmd (Cmd_trans (mk_ref_cmd f.app_term, c), f.app_term, Arg_theorem) in
              mk_cmd (Cmd_composite [app_cmd; t], f.app_term, Arg_theorem) in
          if f.extra_args = [] then cmd
          else
            let cmd = 
              if simple_app then cmd 
              else mk_cmd (Cmd_lambda (extra_args, cmd), f.app_term, Arg_function) in
            mk_cmd (Cmd_pair (mk_ref_cmd f.app_term, cmd), f.app_term, Arg_function)
      in
      let r = get_cmd_rec cmd in
      (r.result, r.result_type) :: env, cmds @ [cmd]
  in
  commands;;
        

let rec pattern_cmd env (Cmd (t, r)) =
  let process_args env args =
    List.fold_left (fun tms cmd ->
      let tms' = pattern_cmd env cmd in
      union tms tms') [] args
  in
  match t with
  | Cmd_ref tm -> if mem tm env then [] else [tm]
  | Cmd_app (_, args) -> process_args env args
  | Cmd_lambda (tms, a1) -> process_args (tms @ env) [a1]
  | Cmd_pair (a1, a2) -> process_args env [a1; a2]
  | Cmd_comb (a1, a2) -> process_args env [a1; a2]
  | Cmd_trans (a1, a2) -> process_args env [a1; a2]
  | Cmd_convert (_, _, a1) -> process_args env [a1]
  | Cmd_composite cmds -> snd (pattern_cmds env cmds)

and pattern_cmds env = function
  | [] -> env, []
  | cmd :: cmds ->
    let tms1 = pattern_cmd env cmd in
    let env = cmd_result cmd :: env in
    let env, tms2 = pattern_cmds env cmds in
    env, union tms1 tms2;;


type env_rec = {
  names: (term * string) list;
  index: int;
};;

let empty_env = {names = []; index = 0};;

let rec name_variant names name =
  if mem name names then name_variant names (name ^ "'")
  else name;;

let get_name env tm =
  try assoc tm env.names
  with Failure _ ->
    Format.sprintf "arg`%s`" (string_of_term tm);;

let extend_env env tm =
  let rec check_name name =
    if can (rev_assoc name) env.names then
      check_name (name ^ "'")
    else
      name in
  let i = env.index + 1 in
  let name = check_name (Format.sprintf "r%d" i) in {
    names = (tm, name) :: env.names;
    index = i;
  }, name;;


let rec cmds_to_exprs env = function
  | [] -> env, []
  | cmd :: cmds ->
    let expr = cmd_expr env cmd in
    let env, name = extend_env env (cmd_result cmd) in
    let env, exprs = cmds_to_exprs env cmds in
    if exprs = [] then env, [expr]
    else
      env, mk_let (name, expr) :: exprs

and cmd_expr env (Cmd (t, r)) =
  match t with
  | Cmd_ref tm -> Raw (get_name env tm)
  | Cmd_app (app, args) ->
    let f_name =
      match app with
      | Var_app tm -> string_of_term tm
      | Const_app rule -> rule.f_name
      | _ -> failwith "cmd_exp: Cmd_app" in
    mk_app (mk_raw f_name, map (cmd_expr env) args)
  | Cmd_lambda (tms, a1) ->
    let names =
      enum_names "tm" (length tms)
      |> map (name_variant (map snd env.names)) in
    let env' = { env with names = zip tms names @ env.names } in
    let body = cmd_expr env' a1 in
    Lambda (map mk_raw names, body)
  | Cmd_pair (a1, a2) ->
    mk_tuple (map (cmd_expr env) [a1; a2])
  | Cmd_trans (a1, a2) ->
    mk_app (mk_raw "TRANS", map (cmd_expr env) [a1; a2])
  | Cmd_comb (a1, a2) ->
    App (mk_raw "MK_COMB", mk_tuple (map (cmd_expr env) [a1; a2]))
  | Cmd_convert (target, source, a) ->
      let arg = cmd_expr env a in
      let expr =
        match (target, source) with
        | Arg_term, Arg_function -> App (Raw "fst", arg)
        | Arg_term, Arg_theorem -> App (Raw "rand", App (Raw "concl", arg))
        | Arg_theorem, Arg_term -> App (Raw "REFL", arg)
        | Arg_theorem, Arg_function -> App (Raw "REFL", App (Raw "fst", arg))
        | Arg_function, Arg_term -> App (Raw "to_func", arg)
        | _ -> failwith "Cmd_convert: unsupported conversion" in
      expr
  | Cmd_composite cmds ->
    let _, exprs = cmds_to_exprs env cmds in
    chain_let exprs;;


let compile_tm tm =
  let vars = frees tm in
  let args = zip vars (map (fst o dest_var) vars) in
  let tm_name = "tm" in
  let tree = build_eval_tree db tm |> optimize_eval_tree in
  let _, cmds = get_eval_commands [] tree in
  let _, p_tms = pattern_cmds (map fst args) cmds in
  let p_names =
    let names = map snd args in
    let arg_names = enum_names "a" (length p_tms) in
    zip p_tms (map (name_variant names) arg_names) in
  let pat, _ = get_pattern tm p_tms in
  let _, exprs = cmds_to_exprs { empty_env with names = p_names @ args } cmds in
  let expr =
    let body = chain_let exprs in
    if pat = Punused then body
    else
      Match (Raw tm_name, 
        [Raw (string_of_pat p_names pat), body;
         Raw "_", Raw "failwith \"bad pattern\""]) in
  Format.fprintf Format.std_formatter "@.@[<v>%a@]@.@." print_expr expr;;