type pat = 
  | Punused
  | Pvar of term
  (* lhs, rhs, optional as clause *)
  | Pcomb of pat * pat * term option
  | Pabs of pat * pat * term option;;

(* Returns 1) a pattern for tm which matches terms in tms, 
           2) a list of unmatched terms in tms *)
let get_pattern =
  let rec subsets s =
    match s with
    | [] -> [[], []]
    | x :: xs ->
      let ss = subsets xs in
      List.fold_left (fun r (a, b) -> (a, x :: b) :: (x :: a, b) :: r) [] ss
  in
  let rec simplify pat =
    match pat with
    | Pvar _ | Punused -> pat
    | Pcomb (p1, p2, p_as) | Pabs (p1, p2, p_as) ->
      let p1 = simplify p1 in
      let p2 = simplify p2 in
      match p1, p2, p_as with
      | Punused, Punused, None -> Punused
      | Punused, Punused, Some tm -> Pvar tm
      | _ -> (match pat with 
              | Pcomb _ -> Pcomb (p1, p2, p_as)
              | Pabs _ -> Pabs (p1, p2, p_as)
              | _ -> failwith "impossible")
  in
  let rec complexity = function
    | Punused | Pvar _ -> 0
    | Pcomb (p1, p2, _) | Pabs (p1, p2, _) ->
      complexity p1 + complexity p2 + 1 
  in
  let rec pattern tm tms =
    match tm with
    | _ when tms = [] -> Punused, []
    | Var _ | Const _ ->
      if mem tm tms then Pvar tm, subtract tms [tm]
      else Punused, tms
    | Comb (ltm, rtm) | Abs (ltm, rtm) ->
      let p_as, tms =
        if mem tm tms then Some tm, filter ((<>) tm) tms
        else None, tms in
      (* let p1, tms1 = pattern ltm tms in
      let p2, tms2 = pattern rtm tms1 in *)
      let p1, p2, tms' = optimize tms ltm rtm in
      match tm with
      | Comb _ -> Pcomb (p1, p2, p_as), tms'
      | Abs _ -> Pabs (p1, p2, p_as), tms'
      | _ -> failwith "impossible"
  and optimize tms ltm rtm =
    let ltms = filter (fun tm -> can (find_term ((=) tm)) ltm) tms and
        rtms = filter (fun tm -> can (find_term ((=) tm)) rtm) tms in
    let tms' = union ltms rtms in
    let ctms = intersect ltms rtms in
    let ltms' = subtract ltms ctms and
        rtms' = subtract rtms ctms in
    let select_best (best, best_c) (s1, s2) =
      let p1 = pattern ltm (s1 @ ltms') |> fst |> simplify in
      let p2 = pattern rtm (s2 @ rtms') |> fst |> simplify in
      let c = complexity p1 + complexity p2 in
      if best_c < 0 || c < best_c then (p1, p2), c else best, best_c in
    let (p1, p2), _ = List.fold_left select_best ((Punused, Punused), -1) (subsets ctms) in
    p1, p2, tms'
  in
  fun tm tms ->
    let pat, tms' = pattern tm tms in
    simplify pat, tms';;
    
      
get_pattern `MAP (f (a + b)) [a + b;2;3;a + b]` [`f:num->num->num`; `a:num`; `a + b`; `b:num`];;
