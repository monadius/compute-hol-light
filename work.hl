type pat = 
  | Punused
  | Pvar of term
  (* lhs, rhs, optional as clause *)
  | Pcomb of pat * pat * term option
  | Pabs of pat * term option;;

let string_of_pat =
  let rec comb_str t p1 p2 p_as =
    match p_as with
    | Some tm -> sprintf "%s (%s, %s) as %s" t (str p1) (str p2) (string_of_term tm)
    | None -> sprintf "%s (%s, %s)" t (str p1) (str p2)
  and str = function
  | Punused -> "_"
  | Pvar tm -> string_of_term tm
  | Pcomb (p1, p2, p_as) -> comb_str "Comb" p1 p2 p_as
  | Pabs (p, p_as) -> comb_str "Abs" Punused p p_as
  in
  str;;

(* Returns 1) a pattern for tm which matches terms in tms, 
           2) a list of unmatched terms in tms *)
let get_pattern =
  let rec subsets s =
    match s with
    | [] -> [[], []]
    | x :: xs ->
      let ss = subsets xs in
      List.fold_left (fun r (a, b) -> (a, x :: b) :: (x :: a, b) :: r) [] ss
  in
  let rec simplify pat =
    match pat with
    | Pvar _ | Punused -> pat
    | Pabs (p, p_as) ->
      let p' = simplify p in
      (match p', p_as with
       | Punused, None -> Punused
       | Punused, Some tm -> Pvar tm
       | _ -> Pabs (p', p_as))
    | Pcomb (p1, p2, p_as) ->
      let p1 = simplify p1 in
      let p2 = simplify p2 in
      match p1, p2, p_as with
      | Punused, Punused, None -> Punused
      | Punused, Punused, Some tm -> Pvar tm
      | _ -> Pcomb (p1, p2, p_as)
  in
  let rec complexity = function
    | Punused | Pvar _ -> 0
    | Pabs (p, _) -> complexity p + 1
    | Pcomb (p1, p2, _) -> complexity p1 + complexity p2 + 1
  in
  let rec pattern tm tms =
    match tm with
    | _ when tms = [] -> Punused, []
    | Var _ | Const _ ->
      if mem tm tms then Pvar tm, subtract tms [tm]
      else Punused, tms
    | Abs (var, btm) ->
      let p_as, tms =
        if mem tm tms then Some tm, subtract tms [tm]
        else None, tms in
      let tms' = filter (fun tm -> free_in tm btm && not (vfree_in var tm)) tms in
      let p1, _ = pattern btm tms' in
      Pabs (p1, p_as), subtract tms tms'
    | Comb (ltm, rtm) ->
      let p_as, tms =
        if mem tm tms then Some tm, subtract tms [tm]
        else None, tms in
      let ltms = filter (fun tm -> free_in tm ltm) tms and
          rtms = filter (fun tm -> free_in tm rtm) tms in
      let ctms = intersect ltms rtms in
      let ltms' = subtract ltms ctms and
          rtms' = subtract rtms ctms in
      let select_best (best, best_c) (s1, s2) =
        let p1 = pattern ltm (s1 @ ltms') |> fst |> simplify in
        let p2 = pattern rtm (s2 @ rtms') |> fst |> simplify in
        let c = complexity p1 + complexity p2 in
        if best_c < 0 || c < best_c then (p1, p2), c else best, best_c in
      let (p1, p2), _ = List.fold_left select_best ((Punused, Punused), -1) (subsets ctms) in
      Pcomb (p1, p2, p_as), subtract tms (union ltms rtms)
  in
  fun tm tms ->
    let pat, tms' = pattern tm tms in
    simplify pat, tms';;


type arg_type = Arg_term | Arg_theorem | Arg_function;;


type eval_cmd = Cmd of eval_cmd_type * eval_cmd_rec

and eval_cmd_rec = {
  result: term;
  result_type: arg_type;
}

and eval_cmd_type = 
  | Cmd_ref of term
  | Cmd_app of app_type * eval_cmd list
  | Cmd_comb of eval_cmd * eval_cmd
  | Cmd_trans of eval_cmd * eval_cmd
  | Cmd_convert of arg_type * arg_type * eval_cmd
  | Cmd_composite of eval_cmd list;;

let mk_cmd (t, res, res_type) = Cmd (t, { result = res; result_type = res_type });;

let mk_ref_cmd tm = mk_cmd (Cmd_ref tm, `T`, Arg_term);;

let get_cmd_rec (Cmd (_, r)) = r;;

let cmd_result (Cmd (_, {result = r})) = r;;


let get_eval_commands =
  let get_type env tm =
    try (assoc tm env).result_type 
    with Failure _ -> 
      if is_var tm && is_fun_ty (type_of tm) then Arg_function else Arg_term 
  in
  let convert_cmd env target tm cmd =
    let ty = get_type env tm in
    if ty = target then cmd
    else
      mk_cmd (Cmd_convert (target, ty, cmd), tm, target)
  in
  let convert_ref env target tm =
    convert_cmd env target tm (mk_ref_cmd tm)
  in
  let comb env op_tm arg_tms =
    List.fold_left (fun (op, op_tm) arg_tm ->
      let arg_cmd = convert_ref env Arg_theorem arg_tm in
      let tm = mk_comb (op_tm, arg_tm) in
      mk_cmd (Cmd_comb (op, arg_cmd), tm, Arg_theorem), tm)
      (convert_ref env Arg_theorem op_tm, op_tm) arg_tms 
    |> fst
  in
  let rec commands env tree =
    match tree with
    | Refl _ -> env, []
    | Func_app f when can (assoc f.app_term) env -> env, []
    | Func_app f ->
      let env, cmds = 
        List.fold_left (fun (env, cmds) arg -> 
          let env', cmds' = commands env arg in
          env', cmds @ cmds') 
          (env, []) f.applied_args in
      let cmd = 
        match f.app_type with
        | Abs_app _ -> failwith "Abs_app is not allowed"
        | Basic_app op ->
          let func = f.extra_args <> [] in
          (* TODO: partial applications *)
          let args = map get_eval_term f.applied_args in
          comb env op args
        | Const_app _ | Var_app _ ->
          let func = f.extra_args <> [] in
          let arg_tms = map get_eval_term f.applied_args in
          let args = map (fun tm ->
            let target = if is_fun_ty (type_of tm) then Arg_function else Arg_term in
            convert_ref env target tm) arg_tms in
          let cmd = mk_cmd (Cmd_app (f.app_type, args), f.app_term, if func then Arg_function else Arg_theorem) in
          if forall (fun arg -> get_type env arg <> Arg_theorem) arg_tms then cmd
          else
            let op, _ = strip_comb f.app_term in
            let c = comb env op arg_tms in
            let t = mk_cmd (Cmd_trans (mk_ref_cmd f.app_term, c), f.app_term, Arg_theorem) in
            mk_cmd (Cmd_composite [cmd; t], f.app_term, Arg_theorem)
      in
      let r = get_cmd_rec cmd in
      (r.result, r) :: env, cmds @ [cmd]
  in
  commands;;
        

let rec pattern_cmd env (Cmd (t, r)) =
  let process_args env args =
    List.fold_left (fun (env, tms) cmd ->
      let env, tms' = pattern_cmd env cmd in
      env, union tms tms') (env, []) args 
  in
  let env, tms =
    match t with
    | Cmd_ref tm -> env, if mem tm env then [] else [tm]
    | Cmd_app (_, args) -> process_args env args
    | Cmd_comb (a1, a2) -> process_args env [a1; a2]
    | Cmd_trans (a1, a2) -> process_args env [a1; a2]
    | Cmd_convert (_, _, a1) -> process_args env [a1]
    | Cmd_composite cmds -> pattern_cmds env cmds in
  r.result :: env, tms

and pattern_cmds env = function
  | [] -> env, []
  | cmd :: cmds ->
    let env, tms1 = pattern_cmd env cmd in
    let env, tms2 = pattern_cmds env cmds in
    env, union tms1 tms2;;


type env_rec = {
  names: (term * string) list;
  index: int;
};;

let empty_env = {names = []; index = 0};;

let get_name env tm =
  try assoc tm env.names
  with Failure _ ->
    Format.sprintf "arg`%s`" (string_of_term tm);;

let extend_env env tm =
  let rec check_name name =
    if can (rev_assoc name) env.names then
      check_name (name ^ "'")
    else
      name in
  let i = env.index + 1 in
  let name = check_name (Format.sprintf "r%d" i) in {
    names = (tm, name) :: env.names;
    index = i;
  }, name;;


let rec cmds_to_exprs env = function
  | [] -> env, []
  | cmd :: cmds ->
    let expr = cmd_expr env cmd in
    let env, name = extend_env env (cmd_result cmd) in
    let env, exprs = cmds_to_exprs env cmds in
    if exprs = [] then env, [expr]
    else
      env, mk_let (name, expr) :: exprs

and cmd_expr env (Cmd (t, r)) =
  match t with
  | Cmd_ref tm -> Raw (get_name env tm)
  | Cmd_app (app, args) ->
    let f_name =
      match app with
      | Var_app tm -> string_of_term tm
      | Const_app rule -> rule.f_name
      | _ -> failwith "cmd_exp: Cmd_app" in
    mk_app (mk_raw f_name, map (cmd_expr env) args)
  | Cmd_trans (a1, a2) ->
    mk_app (mk_raw "TRANS", map (cmd_expr env) [a1; a2])
  | Cmd_comb (a1, a2) ->
    App (mk_raw "MK_COMB", mk_tuple (map (cmd_expr env) [a1; a2]))
  | Cmd_convert (target, source, a) ->
      let arg = cmd_expr env a in
      let expr =
        match (target, source) with
        | Arg_term, Arg_function -> App (Raw "fst", arg)
        | Arg_term, Arg_theorem -> App (Raw "rand", App (Raw "concl", arg))
        | Arg_theorem, Arg_term -> App (Raw "REFL", arg)
        | Arg_theorem, Arg_function -> App (Raw "REFL", App (Raw "fst", arg))
        | Arg_function, Arg_term -> App (Raw "to_func", arg)
        | _ -> failwith "Cmd_convert: unsupported conversion" in
      expr
  | Cmd_composite cmds ->
    let _, exprs = cmds_to_exprs env cmds in
    chain_let exprs;;