needs "tame_defs.hl";;

let rev_ABS1 = define `rev_abs1 a b = a :: b`;;

let rev_NO_ABS = prove
  (`rev xs = fold rev_abs1 xs []`,
  REWRITE_TAC[rev_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; rev_ABS1]);;

let map_filter_ABS1 = define
  `map_filter_abs1 f xs NONE = map_filter f xs
  /\ map_filter_abs1 f xs (SOME r) = r :: map_filter f xs`;;

let map_filter_NO_ABS = prove
  (`map_filter (f:A->(B)option) [] = [] /\
    map_filter f (x :: xs) = map_filter_abs1 f xs (f x)`,
  CONJ_TAC THEN GEN_REWRITE_TAC LAND_CONV [map_filter_ALT] THEN REWRITE_TAC[] THEN
    STRIP_ASSUME_TAC (ISPEC `(f:A->(B)option) x` (cases "option")) THEN
    ASM_REWRITE_TAC[map_filter_ABS1; is_none_DEF; the_DEF]);;

let between_ABS1 = define 
  `between_abs1 ram_2 (pre_1, post_1) =
    if member post_1 ram_2 then
      fst (splitAt ram_2 post_1)
    else
      APPEND post_1 (fst (splitAt ram_2 pre_1))`;;

let between_NO_ABS = prove
  (`between vs ram_1 ram_2 = between_abs1 ram_2 (splitAt ram_1 vs)`,
  REWRITE_TAC[between_DEF] THEN REPEAT LET_TAC THEN 
    ASM_REWRITE_TAC[between_ABS1; fst_DEF]);;

let minimall_ABS1 = define
  `minimall_abs1 m x mxs = if (m x) <= (m mxs) then x else mxs`;;

let minimall_NO_ABS = prove
  (`minimall m (x :: xs) =
    if null xs then x else minimall_abs1 m x (minimall m xs)`,
  REWRITE_TAC[minimall_DEF; minimall_ABS1] THEN LET_TAC THEN REFL_TAC);;

let removeKey_ABS1 = define
  `removeKey_abs1 a (x, y) = ~(a = x)`;;

let removeKey_NO_ABS = prove
  (`removeKey a (ps:(A#B)list) = filter (removeKey_abs1 a) ps`,
  REWRITE_TAC[removeKey_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM] THEN GEN_TAC THEN
    STRIP_ASSUME_TAC (ISPEC `x:A#B` PAIR_SURJECTIVE) THEN
    ASM_REWRITE_TAC[removeKey_ABS1; fst_DEF]);;

let tri_ABS1 = define
  `tri_abs1 (Face vs Final) = (size_list vs = 3) /\
   tri_abs1 (Face vs Nonfinal) = F`;;

let tri_NO_ABS = prove
  (`tri g v = count tri_abs1 (facesAt g v)`,
  REWRITE_TAC[tri_ALT] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; tri_ABS1] THEN GEN_TAC THEN
    STRIP_ASSUME_TAC (SPEC `x:face` (cases "face")) THEN
    STRIP_ASSUME_TAC (SPEC `a1:facetype` (cases "facetype")) THEN
    ASM_REWRITE_TAC[tri_ABS1; vertices_face_DEF; final_face_DEF]);;

let quad_ABS1 = define
  `quad_abs1 (Face vs Final) = (size_list vs = 4) /\
   quad_abs1 (Face vs Nonfinal) = F`;;

let quad_NO_ABS = prove
  (`quad g v = count quad_abs1 (facesAt g v)`,
  REWRITE_TAC[quad_ALT] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; tri_ABS1] THEN GEN_TAC THEN
    STRIP_ASSUME_TAC (SPEC `x:face` (cases "face")) THEN
    STRIP_ASSUME_TAC (SPEC `a1:facetype` (cases "facetype")) THEN
    ASM_REWRITE_TAC[quad_ABS1; vertices_face_DEF; final_face_DEF]);;

let except_ABS1 = define
  `except_abs1 (Face vs Final) = (5 <= size_list vs) /\
   except_abs1 (Face vs Nonfinal) = F`;;

let except_NO_ABS = prove
  (`except g v = count except_abs1 (facesAt g v)`,
  REWRITE_TAC[except_ALT] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; tri_ABS1] THEN GEN_TAC THEN
    STRIP_ASSUME_TAC (SPEC `x:face` (cases "face")) THEN
    STRIP_ASSUME_TAC (SPEC `a1:facetype` (cases "facetype")) THEN
    ASM_REWRITE_TAC[except_ABS1; vertices_face_DEF; final_face_DEF]);;

let neighbors_ABS1 = define
  `neighbors_abs1 v f = nextVertex f v`;;

let neighbors_NO_ABS = prove
  (`neighbors g v = map (neighbors_abs1 v) (facesAt g v)`,
  REWRITE_TAC[neighbors_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; neighbors_ABS1]);;

let nonFinals_ABS1 = define
  `nonFinals_abs1 (Face vs Final) = F /\ nonFinals_abs1 (Face vs Nonfinal) = T`;;

let nonFinals_NO_ABS = prove
  (`nonFinals g = filter nonFinals_abs1 (faces g)`,
  REWRITE_TAC[nonFinals_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM] THEN GEN_TAC THEN
    STRIP_ASSUME_TAC (SPEC `x:face` (cases "face")) THEN
    STRIP_ASSUME_TAC (SPEC `a1:facetype` (cases "facetype")) THEN
    ASM_REWRITE_TAC[nonFinals_ABS1; final_face_DEF]);;

let tame10_ABS1 = define
  `tame10_abs1 n = (13 <= n /\ n <= 15)`;;

let tame10_NO_ABS = prove
  (`tame10 g = tame10_abs1 (countVertices g)`,
  REWRITE_TAC[tame10_ABS1; tame10_DEF; LET_DEF; LET_END_DEF]);;

let tame11a_ABS1 = define
  `tame11a_abs1 g v = 3 <= degree g v`;;

let tame11a_NO_ABS = prove
  (`tame11a g = pred_list (tame11a_abs1 g) (vertices_graph g)`,
  REWRITE_TAC[tame11a_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; tame11a_ABS1]);;

let tame11b_ABS1 = define
  `tame11b_abs1 g v = degree g v <= (if except g v = 0 then 7 else 6)`;;

let tame11b_NO_ABS = prove
  (`tame11b g = pred_list (tame11b_abs1 g) (vertices_graph g)`,
  REWRITE_TAC[tame11b_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; tame11b_ABS1]);;

let tame12o_ABS1 = define
  `tame12o_abs1 g v = (~(degree g v = 6) \/ except g v = 0 \/ vertextype g v = 5,0,1)`;;

let tame12o_NO_ABS = prove
  (`tame12o g = pred_list (tame12o_abs1 g) (vertices_graph g)`,
  REWRITE_TAC[tame12o_ALT] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; tame12o_ABS1]);;

let containsDuplicateEdge_ABS1 = define
  `containsDuplicateEdge_abs1 g f v i j = 
    duplicateEdge g f (nextVertices f i v) (nextVertices f j v)`;;

let containsDuplicateEdge_NO_ABS = prove
  (`containsDuplicateEdge g f v is = 
    containsUnacceptableEdge (containsDuplicateEdge_abs1 g f v) is`,
  REWRITE_TAC[containsDuplicateEdge_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; containsDuplicateEdge_ABS1]);;

let minimalFace_ABS1 = define
  `minimalFace_abs1 (Face vs t) = size_list vs`;;

let minimalFace_NO_ABS = prove
  (`minimalFace fs = minimall minimalFace_abs1 fs`,
  REWRITE_TAC[minimalFace_ALT] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM] THEN GEN_TAC THEN
    STRIP_ASSUME_TAC (SPEC `x:face` (cases "face")) THEN
    ASM_REWRITE_TAC[minimalFace_ABS1; vertices_face_DEF]);;

let heightsNewVertices_ABS1 = define
  `heightsNewVertices_abs1 h_1 h_2 n i = MIN (SUC (h_1 + i)) ((h_2 + n) - i)`;;

let heightsNewVertices_NO_ABS = prove
  (`heightsNewVertices h_1 h_2 n = map (heightsNewVertices_abs1 h_1 h_2 n) (upt 0 n)`,
  REWRITE_TAC[heightsNewVertices_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; heightsNewVertices_ABS1; ADD1]);;

let split_face_NO_ABS = prove
  (`split_face (Face vs t) ram_1 ram_2 newVs =
  Face (APPEND (rev newVs) (APPEND [ram_1] (APPEND (between vs ram_1 ram_2) [ram_2]))) Nonfinal,
  Face (APPEND (APPEND [ram_2] (APPEND (between vs ram_2 ram_1) [ram_1])) newVs) Nonfinal`,
  REWRITE_TAC[split_face_ALT; vertices_face_DEF]);;

let splitFace_ABS2 = (REWRITE_RULE[LET_DEF; LET_END_DEF] o define)
  `splitFace_abs2 (Graph fs n fsa h) ram_1 ram_2 oldF m (f_1, f_2) =
    let vs_1 = between (vertices_face oldF) ram_1 ram_2 in 
    let vs_2 = between (vertices_face oldF) ram_2 ram_1 in 
    let fsaa = replacefacesAt vs_1 oldF [f_1] fsa in 
    let fsab = replacefacesAt vs_2 oldF [f_2] fsaa in 
    let fsac = replacefacesAt [ram_1] oldF [f_2; f_1] fsab in 
    let fsad = replacefacesAt [ram_2] oldF [f_1; f_2] fsac in 
    let fsae = APPEND fsad (replicate m [f_1; f_2]) in
      (f_1, (f_2, Graph
                  (APPEND (replace oldF [f_2] fs) [f_1])
                  (n + m)
                  fsae
                  (APPEND h (heightsNewVertices (nth h ram_1) (nth h ram_2)
                  m))))`;;

let splitFace_NO_ABS = prove
  (`splitFace g ram_1 ram_2 oldF newVs =
    splitFace_abs2 g ram_1 ram_2 oldF 
      (size_list newVs)
      (split_face oldF ram_1 ram_2 newVs)`,
  REWRITE_TAC[splitFace_ALT] THEN
    STRIP_ASSUME_TAC (ISPEC `split_face oldF ram_1 ram_2 newVs` PAIR_SURJECTIVE) THEN
    STRIP_ASSUME_TAC (SPEC `g:graph` (cases "graph")) THEN
    ASM_REWRITE_TAC[splitFace_ABS2; faces_DEF; countVertices_DEF; faceListAt_DEF; heights_DEF]);;

let subdivFacea_ABS1 = define
  `subdivFacea_abs1 v vos (f_1:face, (f_2, ga)) = subdivFacea ga f_2 v 0 vos`;;

let subdivFacea_NO_ABS = prove
  (`subdivFacea g f u n [] = makeFaceFinal f g
    /\ subdivFacea g f u n (NONE :: vos) = subdivFacea g f u (SUC n) vos
    /\ subdivFacea g f u n (SOME v :: vos) =
        if nextVertex f u = v /\ n = 0 then subdivFacea g f v 0 vos
        else
          subdivFacea_abs1 v vos 
            (splitFace g u v f (upt (countVertices g) (countVertices g + n)))`,
  REWRITE_TAC[subdivFacea_ALT] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM] THEN GEN_TAC THEN
    STRIP_ASSUME_TAC (ISPEC `x:face#face#graph` PAIR_SURJECTIVE) THEN
    STRIP_ASSUME_TAC (ISPEC `y:face#graph` PAIR_SURJECTIVE) THEN
    ASM_REWRITE_TAC[subdivFacea_ABS1]);;

let enumAppend_ABS1 = define
  `enumAppend_abs1 is n = APPEND is [n:num]`;;

let enumAppend_ABS2 = define
  `enumAppend_abs2 m is = map (enumAppend_abs1 is) (upt (last is) m)`;;

let enumAppend_NO_ABS = prove
  (`enumAppend nmax iss = maps (enumAppend_abs2 (SUC nmax)) iss`,
  REWRITE_TAC[enumAppend_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; enumAppend_ABS2] THEN GEN_TAC THEN
    REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; enumAppend_ABS1]);;

let enumBase_ABS2 = define
  `enumBase_abs2 i = [i:num]`;;

let enumBase_NO_ABS = prove
  (`enumBase nmax = map enumBase_abs2 (upt 0 (SUC nmax))`,
  REWRITE_TAC[enumBase_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; enumBase_ABS2]);;

let enumerator_ABS2 = define
  `enumerator_abs2 m is = 0 :: APPEND is [m]`;;

let enumerator_ABS3 = define
  `enumerator_abs3 outer k nmax = 
    map (enumerator_abs2 (PRE outer)) 
        (funpow k (enumAppend nmax) (enumBase nmax))`;;

let enumerator_NO_ABS = prove
  (`enumerator inner outer = enumerator_abs3 outer (inner - 3) (outer - 2)`,
  REWRITE_TAC[enumerator_ALT; enumerator_ABS3] THEN
    REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; enumerator_ABS2; APPEND; ARITH_RULE `PRE n = n - 1`]);;

let indexToVertexList_ABS1 = define
  `indexToVertexList_abs1 f v k = nextVertices f k v`;;

let indexToVertexList_NO_ABS = prove
  (`indexToVertexList f v is = hideDups (map (indexToVertexList_abs1 f v) is)`,
  REWRITE_TAC[indexToVertexList_DEF] THEN
    REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; indexToVertexList_ABS1]);;

let faceSquanderLowerBound_ABS1 = define
  `faceSquanderLowerBound_abs1 (Face vs t) = squanderFace (size_list vs)`;;

let faceSquanderLowerBound_NO_ABS = prove
  (`faceSquanderLowerBound g = 
    listSum (finals g) faceSquanderLowerBound_abs1`,
  REWRITE_TAC[faceSquanderLowerBound_DEF] THEN
    REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM] THEN GEN_TAC THEN
    STRIP_ASSUME_TAC (SPEC `x:face` (cases "face")) THEN
    ASM_REWRITE_TAC[faceSquanderLowerBound_ABS1; vertices_face_DEF]);;

let deleteAround_ABS1 = define
  `deleteAround_abs1 f n =
    if size_list (vertices_face f) = 4 then
      [n; nextVertex f n]
    else [n]`;;

let deleteAround_ABS2 = define
  `deleteAround_abs2 v f = deleteAround_abs1 f (nextVertex f v)`;;

let deleteAround_NO_ABS = prove
  (`deleteAround g v ps =
    removeKeyList (maps (deleteAround_abs2 v) (facesAt g v)) ps`,
  REWRITE_TAC[deleteAround_ALT] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; deleteAround_ABS2; deleteAround_ABS1]);;

let excessTable_ABS1 = define
  `excessTable_abs1 v e = if 0 < e then SOME (v:num, e) else NONE`;;

let excessTable_ABS2 = define
  `excessTable_abs2 g v = excessTable_abs1 v (excessAt g v)`;;

let excessTable_NO_ABS = prove
  (`excessTable g vs = map_filter (excessTable_abs2 g) vs`,
  REWRITE_TAC[excessTable_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; excessTable_ABS2; excessTable_ABS1; LET_DEF; LET_END_DEF]);;

let polysizes_ABS1 = define
  `polysizes_abs1 lb n = lb + squanderFace n < 15410`;;

let polysizes_ABS2 = define
  `polysizes_abs2 p lb = filter (polysizes_abs1 lb) (upt 3 (p + 4))`;;

let polysizes_NO_ABS = prove
  (`polysizes p g = polysizes_abs2 p (squanderLowerBound g)`,
  REWRITE_TAC[polysizes_ALT; polysizes_ABS2; maxGon_DEF; ARITH_RULE `SUC (p + 3) = p + 4`] THEN
    REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; polysizes_ABS1]);;

let generatePolygonTame_ABS1 = define
  `generatePolygonTame_abs1 ga = (tame10ub ga /\ tame11b ga)`;;

let generatePolygonTame_ABS2 = define
  `generatePolygonTame_abs2 g f v is = ~(containsDuplicateEdge g f v is)`;;

let generatePolygonTame_NO_ABS = prove
  (`generatePolygonTame n v f g =
      filter generatePolygonTame_abs1
            (map (subdivFace g f)
                 (map (indexToVertexList f v)
                      (filter (generatePolygonTame_abs2 g f v)
                              (enum n (size_list (vertices_face f))))))`,
  REWRITE_TAC[generatePolygonTame_ALT] THEN
    SUBGOAL_THEN `(\ga. ~notame ga) = generatePolygonTame_abs1` ASSUME_TAC THENL [
      REWRITE_TAC[FUN_EQ_THM; generatePolygonTame_ABS1; notame_DEF];
      ALL_TAC
    ] THEN
    ASM_REWRITE_TAC[] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; generatePolygonTame_ABS2]);;

let next_tame0_ABS1 = define
  `next_tame0_abs1 g f i = generatePolygonTame i (minimalVertex g f) f g`;;

let next_tame0_ABS2 = define
  `next_tame0_abs2 p g f =
    maps (next_tame0_abs1 g f) (polysizes p g)`;;

let next_tame0_ABS4 = define
  `next_tame0_abs4 p g fs = 
    if null fs then [] else next_tame0_abs2 p g (minimalFace fs)`;;

let next_tame0_NO_ABS = prove
  (`next_tame0 p g = next_tame0_abs4 p g (nonFinals g)`,
  REWRITE_TAC[next_tame0_ALT; next_tame0_ABS4; next_tame0_ABS2] THEN
    REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; next_tame0_ABS1]);;

let next_tame_ABS1 = define
  `next_tame_abs1 g = (~(final_graph g) \/ is_tame g)`;;

let next_tame_NO_ABS = prove
  (`next_tame p g = filter next_tame_abs1 (next_tame0 p g)`,
  REWRITE_TAC[next_tame_ALT] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; next_tame_ABS1]);;

let tameEnumFilterBounded_ABS1 = define
  `tameEnumFilterBounded_abs1 g s = if final_graph g then insert_mod_trie (fgraph g) s else s`;;

let tameEnumFilterBounded_NO_ABS = prove
  (`tameEnumFilterBounded p n =
      worklist_tree_bounded n
        (next_tame p)
        tameEnumFilterBounded_abs1
        [seed p]
        (Tries [] [])`,
  REWRITE_TAC[tameEnumFilterBounded_DEF] THEN REPEAT (FIRST [AP_TERM_TAC; AP_THM_TAC]) THEN
    REWRITE_TAC[FUN_EQ_THM; tameEnumFilterBounded_ABS1]);;






