(* Make sure that load_path contains a path to compute_hol4.hl *)
(* load_path := "path_to_compute_hol4" :: !load_path *)
needs "compute_hol4.hl";;

open Compute;;

(* Basic usage *)

(* Add rewrite rules (equality theorems) to the default global compset *)
add_funs [ARITH_ADD; ARITH_SUC];;

(* Evaluate basic expressions *)
EVAL_CONV `3 + 3 + 1`;;
EVAL_CONV `3 + 2 + 4`;;

(* The multiplication is not evaluated because we have not added a multiplication theorem yet *)
EVAL_CONV `3 * (3 + 2)`;;

add_funs [ARITH_MULT];;
EVAL_CONV `3 * (3 + 2)`;;

(* We can also use EVAL_RULE and EVAL_TAC *)
let th = ARITH_RULE `3 * 3 + 2 * 2 > 4`;;
EVAL_RULE th;;
prove(`3 * 3 + 2 * 2 = 13`, EVAL_TAC);;

(* We can remove existing rules *)
del_funs [ARITH_ADD];;
EVAL_CONV `3 + 3`;;
(* Note that multiplication still works (the multiplication rule keeps an internal link to the addition rule ) *)
EVAL_CONV `3 * 3`;;

add_funs [ARITH_ADD];;

(* Evaluation of lambdas *)
EVAL_CONV `(\x. x + 3) 4`;;
EVAL_CONV `(\x y. x * y + x) 3`;;
EVAL_CONV `(\x y. x * y + x) 3 4`;;

add_funs [MAP];;
EVAL_CONV `MAP SUC [1;2;3;4]`;;
EVAL_CONV `MAP (\x. x + 3) [1;2;3;4]`;;
EVAL_CONV `MAP (\x. x - 3) [1;2;3*3]`;;
EVAL_CONV `MAP (CONS 1) [[1]; [1;1+1]]`;;

(* Basic logical and conditional operations *)
EVAL_CONV `if 3 * 3 = 9 then (1 + 1 = 3) /\ A else B \/ B`;;

add_funs [ARITH_EQ];;
EVAL_CONV `if 3 * 3 = 9 then (1 + 1 = 3) /\ A else B \/ B`;;

(* Both conditional branches are evaluated if the condition cannot be decided *)
EVAL_CONV `if 3 * 3 > 9 then (1 + 1 = 3) /\ A else B \/ B`;;

(* Infinite loop for tests *)
(* Note: `inf_loop n = inf_loop (n + 1)` is recognized by the computeLib as an infinite loop *)
let inf_loop = define `inf_loop n = (inf_loop n /\ T)`;;
let inf_loop_num = define `(inf_loop_num n):num = if T then inf_loop_num (n + 1) else inf_loop_num n`;;

add_funs [inf_loop; inf_loop_num];;
(* Infinite evaluation (uncomment, run, and stop with Ctrl+C) *)
(* EVAL_CONV `inf_loop 1` *)

(* Evaluated without problems *)
EVAL_CONV `if 3 * 3 = 9 then 1 + 1 = 3 else (inf_loop 1)`;;

(* Infinite loop *)
(* EVAL_CONV `if 3 * 3 > 9 then 1 + 1 = 3 else (inf_loop 1)` *)

add_funs [ARITH_GT; ARITH_GE];;
EVAL_CONV `if 3 * 3 > 9 then inf_loop 1 else 1 + 1 * 4 > 3`;;

(* In general, EVAL_CONV eagerly evaluates all arguments.
But if the given equality theorem is in the form |- lhs x = \y. rhs,
then `lhs a b` is evaluated as follows: `a` is evaluated first, the
equality theorem is applied, and `b` is evaluated only if there are no
other reductions *)

let lazy_def = define `lazy x = \y. if x > 3 then y else 2 * x`;;
let eager_def = define `eager x y = if x > 3 then y else 2 * x`;;
add_funs [lazy_def; eager_def];;

EVAL_CONV `lazy 1 3`;;
EVAL_CONV `eager 1 3`;;
EVAL_CONV `lazy 1 (inf_loop_num 3)`;;
(* Infinite loops *)
(* EVAL_CONV `lazy 4 (inf_loop_num 3)` *)
(* EVAL_CONV `eager 1 (inf_loop_num 3)` *)

(* Utility functions for making all arguments lazy or strict *)
let lazy_eager = lazyfy_thm eager_def;;
(* Note: we override the existing definitions *)
add_funs [lazy_eager];;
EVAL_CONV `eager 1 3`;;
EVAL_CONV `eager 1 (inf_loop_num 3)`;;

let eager_lazy = strictify_thm lazy_def;;
(* This does not override the existing definition because the theorems
are sorted internally by the number of strict arguments: a theorem with
the minimum number of strict argument is applied first *)
add_funs [eager_lazy];;
EVAL_CONV `lazy 1 3`;;
(* No infinite loop *)
EVAL_CONV `lazy 1 (inf_loop_num 3)`;;

del_funs [lazy_def];;
add_funs [eager_lazy];;
(* Infinite loop *)
(* EVAL_CONV `lazy 1 (inf_loop_num 3)` *)



