needs "compiled_eval.hl";;

let true_tm = standardize_tm `T`;;
let COND_T = (standardize o prove)(`(if T then (t:A) else e) = t`, REWRITE_TAC[]);;
let COND_F = (standardize o prove)(`(if F then (t:A) else e) = e`, REWRITE_TAC[]);;

let f_EQ =
  let const = `(=):num->num->bool` in
  fun a b -> NUM_EQ_CONV (list_mk_comb (const, [a; b]));;

let f_SUC =
  let const = `SUC` in
  fun a -> NUM_SUC_CONV (mk_comb (const, a));;

let f_PRE =
  let const = `PRE` in
  fun a -> NUM_PRE_CONV (mk_comb (const, a));;

let f_ADD =
  let const = `+` in
  fun a b -> NUM_ADD_CONV (list_mk_comb (const, [a; b]));;

let f_SUB =
  let const = `-` in
  fun a b -> NUM_SUB_CONV (list_mk_comb (const, [a; b]));;

let f_MUL =
  let const = `*` in
  fun a b -> NUM_MULT_CONV (list_mk_comb (const, [a; b]));;

let f_LE =
  let const = `<=` in
  fun a b -> NUM_LE_CONV (list_mk_comb (const, [a; b]));;

let f_LT =
  let const = `<` in
  fun a b -> NUM_LT_CONV (list_mk_comb (const, [a; b]));;

let f_GE =
  let const = `>=` in
  fun a b -> NUM_GE_CONV (list_mk_comb (const, [a; b]));;

let f_GT =
  let const = `>` in
  fun a b -> NUM_GT_CONV (list_mk_comb (const, [a; b]));;

let f_NOT =
  let NOT_CLAUSES_case1, NOT_CLAUSES_case2, NOT_CLAUSES_case3 =
    match split_thm NOT_CLAUSES with
    | [th1; th2; th3] -> (th1, th2, th3)
    | _ -> failwith "error"
     in
  let var_t = standardize_tm (mk_var ("t", `:bool`)) in
  let rec f_NOT tm1 =
    try
      match tm1 with
      | Comb (Const ("~", _), t) -> INST [t, var_t] NOT_CLAUSES_case1
      | Const ("T", _) -> NOT_CLAUSES_case2
      | Const ("F", _) -> NOT_CLAUSES_case3
      | _ -> failwith "No match: f_NOT"
    with
    | Failure msg -> eval_error msg "f_NOT" [tm1]
    | Eval_error err -> eval_error_propagate err "f_NOT" [tm1]
     in
  f_NOT;;

let f_AND =
  let AND_CLAUSES_case1, AND_CLAUSES_case2, AND_CLAUSES_case3, AND_CLAUSES_case4, AND_CLAUSES_case5 =
    match split_thm AND_CLAUSES with
    | [th1; th2; th3; th4; th5] -> (th1, th2, th3, th4, th5)
    | _ -> failwith "error"
     in
  let var_t = standardize_tm (mk_var ("t", `:bool`)) in
  let rec f_AND tm1 tm2 =
    try
      match (tm1, tm2) with
      | (Const ("T", _), t) -> INST [t, var_t] AND_CLAUSES_case1
      | (t, Const ("T", _)) -> INST [t, var_t] AND_CLAUSES_case2
      | (Const ("F", _), t) -> INST [t, var_t] AND_CLAUSES_case3
      | (t, Const ("F", _)) -> INST [t, var_t] AND_CLAUSES_case4
      | _ -> failwith "No match: f_AND"
    with
    | Failure msg -> eval_error msg "f_AND" [tm1; tm2]
    | Eval_error err -> eval_error_propagate err "f_AND" [tm1; tm2]
     in
  f_AND;;

let f_OR =
  let OR_CLAUSES_case1, OR_CLAUSES_case2, OR_CLAUSES_case3, OR_CLAUSES_case4, OR_CLAUSES_case5 =
    match split_thm OR_CLAUSES with
    | [th1; th2; th3; th4; th5] -> (th1, th2, th3, th4, th5)
    | _ -> failwith "error"
     in
  let var_t = standardize_tm (mk_var ("t", `:bool`)) in
  let rec f_OR tm1 tm2 =
    try
      match (tm1, tm2) with
      | (Const ("T", _), t) -> INST [t, var_t] OR_CLAUSES_case1
      | (t, Const ("T", _)) -> INST [t, var_t] OR_CLAUSES_case2
      | (Const ("F", _), t) -> INST [t, var_t] OR_CLAUSES_case3
      | (t, Const ("F", _)) -> INST [t, var_t] OR_CLAUSES_case4
      | _ -> failwith "No match: f_OR"
    with
    | Failure msg -> eval_error msg "f_OR" [tm1; tm2]
    | Eval_error err -> eval_error_propagate err "f_OR" [tm1; tm2]
     in
  f_OR;;

let default_db () =
  let db = empty_db() in
  List.iter (fun c -> set_rule db c) [
    `(=):A->A->bool`;
    `+`; `-`; `SUC`; `*`; `PRE`; `<=`; `<`; `>=`; `>`;
    `~`; `/\`; `\/`
  ];
  db;;

