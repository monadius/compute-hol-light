needs "arith_options.hl";;
Arith_options.base := 100;;
Arith_options.cached := false;;

needs "new_arith/nat_arith.hl";;
let f_SUC = Nat_arith.nsuc;;
let f_PRE = Nat_arith.npre;;
let f_ADD = Nat_arith.nadd;;
let f_SUB = Nat_arith.nsub;;
let f_MUL = Nat_arith.nmul;;
let f_LE tm1 tm2 = fst (Nat_arith.nle tm1 tm2);;
let f_LT tm1 tm2 = fst (Nat_arith.nlt tm1 tm2);;
let f_MIN = Nat_arith.nmin;;
let f_MAX = Nat_arith.nmax;;

let f_EQ_num tm1 tm2 = fst (Nat_arith.neq tm1 tm2);;

let numeral = Nat_arith.replace_numerals;;
install_user_printer ("nat", Nat_arith.print_nat);;
(* install_parser ("nat", Nat_arith.parse_nat);; *)

loadt "eval_compile.hl";;

let standardize = Misc_vars.standardize;;
let standardize_tm = Misc_vars.standardize_tm;;

let tame_default_db ~eliminate_abs () =
  let db = empty_db ~eliminate_abs "tame" in
  List.iter (fun c -> set_rule db c) [
    `(=):num->num->bool`; `(=):(num)list->(num)list->bool`; `(=):face->face->bool`;
    `(=):num#num#num->num#num#num->bool`;
    `(=):bool->bool->bool`;
    `(=):A->A->bool`;
    `+`; `-`; `SUC`; `*`; `PRE`; `<=`; `<`; `>=`; `>`; `MIN`; `MAX`;
    `~`;
  ];
  add_extra_rule db ("Nat_arith.REPLACE_NUMERALS", Nat_arith.REPLACE_NUMERALS);
  List.iter (add_extra_rewrite db) ["GT", GT; "GE", GE];
  db;;

let true_tm = standardize_tm `T`;;
let p_var_bool = `P: bool`;;
let T_AND = TAUT `T /\ P <=> P` and
    F_AND = TAUT `F /\ P <=> F` and
    T_OR = TAUT `T \/ P <=> T` and
    F_OR = TAUT `F \/ P <=> P`;;

let f_NOT =
  let NOT_CLAUSES_case1, NOT_CLAUSES_case2, NOT_CLAUSES_case3 =
    match split_thm NOT_CLAUSES with
    | [th1; th2; th3] -> (th1, th2, th3)
    | _ -> failwith "error"
     in
  let var_t = standardize_tm (mk_var ("t", `:bool`)) in
  let rec f_NOT tm1 =
    try
      match tm1 with
      | Comb (Const ("~", _), t) -> INST [t, var_t] NOT_CLAUSES_case1
      | Const ("T", _) -> NOT_CLAUSES_case2
      | Const ("F", _) -> NOT_CLAUSES_case3
      | _ -> failwith "No match: f_NOT"
    with
    | Failure msg -> eval_error msg "f_NOT" [tm1]
    | Eval_error err -> eval_error_propagate err "f_NOT" [tm1]
     in
  f_NOT;;

(* let f_EQ_num =
  let const = standardize_tm `(=):num->num->bool` in
  fun t1 t2 -> NUM_EQ_CONV (mk_comb (mk_comb (const, t1), t2));; *)

let f_EQ_num_list =
  let refl_eq = (standardize o prove)(`xs:(num)list = xs <=> T`, REWRITE_TAC[]) in
  let f_const = standardize_tm `F` in
  let var_x = standardize_tm `x:num` in
  let var_y = standardize_tm `y:num` in
  let var_xs = standardize_tm `xs:(num)list` in
  let var_ys = standardize_tm `ys:(num)list` in
  let list_case1 = (standardize o prove)(`CONS (x:num) xs = CONS y ys <=> x = y /\ xs = ys`, REWRITE_TAC[injectivity "list"]) and
      list_case2 = (standardize o prove)(`[] = CONS (x:num) xs <=> F`, REWRITE_TAC[distinctness "list"]) and
      list_case3 = (standardize o prove)(`CONS (x:num) xs = [] <=> F`, REWRITE_TAC[distinctness "list"]) in
  let rec f_EQ tm1 tm2 =
    if tm1 = tm2 then INST[tm1, var_xs] refl_eq
    else
      match (tm1, tm2) with
      | Comb (Comb (Const ("CONS", _), x), xs), Comb (Comb (Const ("CONS", _), y), ys) ->
        let th = INST [ys, var_ys; xs, var_xs; y, var_y; x, var_x] list_case1 in
        let rhs = rand (concl th) in
        let rhs_eq =
          let op, a2 = dest_comb rhs in
          let op, a1 = dest_comb op in
          let a1 = f_EQ_num x y in
          if rand (concl a1) = f_const then
            let and_th = INST[a2, p_var_bool] F_AND in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), REFL a2)) and_th
          else
            let a2 = f_EQ xs ys in
            let and_th = INST[rand (concl a2), p_var_bool] T_AND in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), a2)) and_th in
        TRANS th rhs_eq
      | Const ("NIL", _), Comb (Comb (Const ("CONS", _), x), xs) ->
        INST[x, var_x; xs, var_xs] list_case2
      | Comb (Comb (Const ("CONS", _), x), xs), Const ("NIL", _) ->
        INST[x, var_x; xs, var_xs] list_case3
      | _ -> failwith "f_EQ_num_list"
  in
  f_EQ;;

let f_EQ_face =
  let refl_eq = (standardize o prove)(`f:face = f <=> T`, REWRITE_TAC[]) in
  let face_case1 = (standardize o prove)(`Face xs Final = Face ys Final <=> xs = ys`, REWRITE_TAC[injectivity "face"]) and
      face_case2 = (standardize o prove)(`Face xs Nonfinal = Face ys Nonfinal <=> xs = ys`, REWRITE_TAC[injectivity "face"]) and
      face_case3 = (standardize o prove)(`Face xs Final = Face ys Nonfinal <=> F`, REWRITE_TAC[injectivity "face"; distinctness "facetype"]) and
      face_case4 = (standardize o prove)(`Face xs Nonfinal = Face ys Final <=> F`, REWRITE_TAC[injectivity "face"; distinctness "facetype"]) in
  let var_f = standardize_tm `f:face` in
  let var_xs = standardize_tm `xs:(num)list` in
  let var_ys = standardize_tm `ys:(num)list` in
  let f_EQ tm1 tm2 =
    if tm1 = tm2 then INST[tm1, var_f] refl_eq
    else
      match (tm1, tm2) with
      | Comb (Comb (Const ("Face", _), xs), Const ("Final", _)), Comb (Comb (Const ("Face", _), ys), Const ("Final", _)) ->
        let th = INST[xs, var_xs; ys, var_ys] face_case1 in
        let rhs_eq = f_EQ_num_list xs ys in
        TRANS th rhs_eq
      | Comb (Comb (Const ("Face", _), xs), Const ("Nonfinal", _)), Comb (Comb (Const ("Face", _), ys), Const ("Nonfinal", _)) ->
        let th = INST[xs, var_xs; ys, var_ys] face_case2 in
        let rhs_eq = f_EQ_num_list xs ys in
        TRANS th rhs_eq
      | Comb (Comb (Const ("Face", _), xs), Const ("Final", _)), Comb (Comb (Const ("Face", _), ys), Const ("Nonfinal", _)) ->
        INST[xs, var_xs; ys, var_ys] face_case3
      | Comb (Comb (Const ("Face", _), xs), Const ("Nonfinal", _)), Comb (Comb (Const ("Face", _), ys), Const ("Final", _)) ->
        INST[xs, var_xs; ys, var_ys] face_case4
      | _ -> failwith "f_EQ_face"
  in
  f_EQ;;

let f_EQ_bool =
  let tt_eq = (standardize o TAUT) `T = T <=> T` and
      ff_eq = (standardize o TAUT) `F = F <=> T` and
      tf_eq = (standardize o TAUT) `T = F <=> F` and
      ft_eq = (standardize o TAUT) `F = T <=> F` in
  let f_EQ tm1 tm2 =
    match tm1 with
    | Const ("T", _) ->
      (match tm2 with Const ("T", _) -> tt_eq | Const ("F", _) -> tf_eq | _ -> failwith "error")
    | Const ("F", _) ->
      (match tm2 with Const ("T", _) -> ft_eq | Const ("F", _) -> ff_eq | _ -> failwith "error")
    | _ -> failwith "error"
  in
  f_EQ;;

let f_EQ_num_num_num =
  let refl_eq = (standardize o prove)(`p:(num#num#num) = p <=> T`, REWRITE_TAC[]) in
  let var_p = standardize_tm `p:num#num#num` in
  let var_a = standardize_tm `a:num` in
  let var_b = standardize_tm `b:num` in
  let var_c = standardize_tm `c:num` in
  let var_x = standardize_tm `x:num` in
  let var_y = standardize_tm `y:num` in
  let var_z = standardize_tm `z:num` in
  let pair_eq = (standardize o prove)(`(a:num,b:num,c:num) = (x,y,z) <=> a = x /\ (b = y /\ c = z)`, REWRITE_TAC[PAIR_EQ]) in
  let f_EQ tm1 tm2 =
    if tm1 = tm2 then INST[tm1, var_p] refl_eq
    else
      match (tm1, tm2) with
      | Comb (Comb (Const (",", _), a), Comb (Comb (Const (",", _), b), c)), Comb (Comb (Const (",", _), x), Comb (Comb (Const (",", _), y), z)) ->
        let th = INST [a, var_a; b, var_b; c, var_c; x, var_x; y, var_y; z, var_z] pair_eq in
        let rhs = rand (concl th) in
        let rhs_eq =
          let op, a2 = dest_comb rhs in
          let op, a1 = dest_comb op in
          let a1_eq = f_EQ_num a x in
          if rand (concl a1_eq) = true_tm then
            let a2_eq =
              let op, a2 = dest_comb a2 in
              let op, a1 = dest_comb op in
              let a1_eq = f_EQ_num b y in
              if rand (concl a1_eq) = true_tm then
                let a2_eq = f_EQ_num c z in
                let and_th = INST[rand (concl a2_eq), p_var_bool] T_AND in
                TRANS (MK_COMB (MK_COMB (REFL op, a1_eq), a2_eq)) and_th
              else
                let and_th = INST[a2, p_var_bool] F_AND in
                TRANS (MK_COMB (MK_COMB (REFL op, a1_eq), REFL a2)) and_th in
            let and_th = INST[rand (concl a2_eq), p_var_bool] T_AND in
            TRANS (MK_COMB (MK_COMB (REFL op, a1_eq), a2_eq)) and_th
          else
            let and_th = INST[a2, p_var_bool] F_AND in
            TRANS (MK_COMB (MK_COMB (REFL op, a1_eq), REFL a2)) and_th in
        TRANS th rhs_eq
      | _ -> failwith "f_EQ_num_num_num"
  in
  f_EQ;;

let eq_types = ref [];;

(* Need to include additional cases *)
let f_EQ =
  let num_eq = `(=):num->num->bool` in
  let var_a_bool = `a:bool` in
  let var_xs_num_list = `xs:(num)list` in
  let var_ys_num_list = `ys:(num)list` in
  let f_const = `F` in
  let f_and = prove(`F /\ a <=> F`, REWRITE_TAC[]) in
  let t_and = prove(`T /\ a <=> a`, REWRITE_TAC[]) in
  let tf_eq = TAUT `T = F <=> F` and
      ft_eq = TAUT `F = T <=> F` in
  let refl_eq = prove(`x:A = x <=> T`, REWRITE_TAC[]) in
  let pair_eq = prove(`x:A,y:B = a,b <=> x = a /\ y = b`, REWRITE_TAC[PAIR_EQ]) in
  let option_case1 = prove(`SOME (x:A) = SOME y <=> x = y`, REWRITE_TAC[injectivity "option"]) and
      option_case2 = prove(`NONE = SOME (x:A) <=> F`, REWRITE_TAC[distinctness "option"]) and
      option_case3 = prove(`SOME (x:A) = NONE <=> F`, REWRITE_TAC[distinctness "option"]) in
  let list_case1 = prove(`CONS (x:A) xs = CONS y ys <=> x = y /\ xs = ys`, REWRITE_TAC[injectivity "list"]) and
      list_case2 = prove(`[] = CONS (x:A) xs <=> F`, REWRITE_TAC[distinctness "list"]) and
      list_case3 = prove(`CONS (x:A) xs = [] <=> F`, REWRITE_TAC[distinctness "list"]) in
  let face_case1 = prove(`Face xs Final = Face ys Final <=> xs = ys`, REWRITE_TAC[injectivity "face"]) and
      face_case2 = prove(`Face xs Nonfinal = Face ys Nonfinal <=> xs = ys`, REWRITE_TAC[injectivity "face"]) and
      face_case3 = prove(`Face xs Final = Face ys Nonfinal <=> F`, REWRITE_TAC[injectivity "face"; distinctness "facetype"]) and
      face_case4 = prove(`Face xs Nonfinal = Face ys Final <=> F`, REWRITE_TAC[injectivity "face"; distinctness "facetype"]) in
  let facetype_case1 = prove(`Final = Nonfinal <=> F`, REWRITE_TAC[distinctness "facetype"]) and
      facetype_case2 = prove(`Nonfinal = Final <=> F`, REWRITE_TAC[distinctness "facetype"])
  in
  let rec f_EQ tm1 tm2 =
    eq_types := type_of tm1 :: !eq_types;
    try
      match (tm1, tm2) with
      | Comb (Const ("NUMERAL", _), _), Comb (Const ("NUMERAL", _), _) ->
        NUM_EQ_CONV (mk_comb (mk_comb (num_eq, tm1), tm2))
      | x, y when x = y ->
        let ty = type_of x in
        let var_x = mk_var ("x", ty) in
        INST[x, var_x] (INST_TYPE [ty, aty] refl_eq)
      | Const ("T", _), Const ("F", _) -> tf_eq
      | Const ("F", _), Const ("T", _) -> ft_eq
      | Comb (Comb (Const (",", Tyapp ("fun", [xty; Tyapp ("fun", [yty; _])])), x), y), Comb (Comb (Const (",", _), a), b) ->
        let var_x = mk_var ("x", xty) in
        let var_y = mk_var ("y", yty) in
        let var_a = mk_var ("a", xty) in
        let var_b = mk_var ("b", yty) in
        let th = INST [b, var_b; a, var_a; y, var_y; x, var_x] (INST_TYPE [xty, aty; yty, bty] pair_eq) in
        let rhs = rand (concl th) in
        let rhs_eq =
          let op, a2 = dest_comb rhs in
          let op, a1 = dest_comb op in
          let a1 = f_EQ x a in
          if rand (concl a1) = f_const then
            let and_th = INST[a2, var_a_bool] f_and in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), REFL a2)) and_th
          else
            let a2 = f_EQ y b in
            let and_th = INST[rand (concl a2), var_a_bool] t_and in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), a2)) and_th in
        TRANS th rhs_eq
      | Comb (Const ("SOME", Tyapp ("fun", [ty; _])), x), Comb (Const ("SOME", _), y) ->
        let var_x = mk_var ("x", ty) in
        let var_y = mk_var ("y", ty) in
        let th = INST [x, var_x; y, var_y] (INST_TYPE [ty, aty] option_case1) in
        let rhs_eq = f_EQ x y in
        TRANS th rhs_eq
      | Const ("NONE", Tyapp ("option", [ty])), Comb (Const ("SOME", _), x) ->
        let var_x = mk_var ("x", ty) in
        INST[x, var_x] (INST_TYPE [ty, aty] option_case2)
      | Comb (Const ("SOME", _), x), Const ("NONE", Tyapp ("option", [ty])) ->
        let var_x = mk_var ("x", ty) in
        INST[x, var_x] (INST_TYPE [ty, aty] option_case3)
      | Comb (Comb (Const ("CONS", Tyapp ("fun", [xty; Tyapp ("fun", [xsty; _])])), x), xs), Comb (Comb (Const ("CONS", _), y), ys) ->
        let var_x = mk_var ("x", xty) in
        let var_y = mk_var ("y", xty) in
        let var_xs = mk_var ("xs", xsty) in
        let var_ys = mk_var ("ys", xsty) in
        let th = INST [ys, var_ys; xs, var_xs; y, var_y; x, var_x] (INST_TYPE [xty, aty] list_case1) in
        let rhs = rand (concl th) in
        let rhs_eq =
          let op, a2 = dest_comb rhs in
          let op, a1 = dest_comb op in
          let a1 = f_EQ x y in
          if rand (concl a1) = f_const then
            let and_th = INST[a2, var_a_bool] f_and in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), REFL a2)) and_th
          else
            let a2 = f_EQ xs ys in
            let and_th = INST[rand (concl a2), var_a_bool] t_and in
            TRANS (MK_COMB (MK_COMB (REFL op, a1), a2)) and_th in
        TRANS th rhs_eq
      | Const ("NIL", (Tyapp ("list", [xty]) as xsty)), Comb (Comb (Const ("CONS", _), x), xs) ->
        let var_x = mk_var ("x", xty) in
        let var_xs = mk_var ("xs", xsty) in
        INST[x, var_x; xs, var_xs] (INST_TYPE [xty, aty] list_case2)
      | Comb (Comb (Const ("CONS", _), x), xs), Const ("NIL", (Tyapp ("list", [xty]) as xsty)) ->
        let var_x = mk_var ("x", xty) in
        let var_xs = mk_var ("xs", xsty) in
        INST[x, var_x; xs, var_xs] (INST_TYPE [xty, aty] list_case3)
      | Comb (Comb (Const ("Face", _), xs), Const ("Final", _)), Comb (Comb (Const ("Face", _), ys), Const ("Final", _)) ->
        let th = INST[xs, var_xs_num_list; ys, var_ys_num_list] face_case1 in
        let rhs_eq = f_EQ xs ys in
        TRANS th rhs_eq
      | Comb (Comb (Const ("Face", _), xs), Const ("Nonfinal", _)), Comb (Comb (Const ("Face", _), ys), Const ("Nonfinal", _)) ->
        let th = INST[xs, var_xs_num_list; ys, var_ys_num_list] face_case2 in
        let rhs_eq = f_EQ xs ys in
        TRANS th rhs_eq
      | Comb (Comb (Const ("Face", _), xs), Const ("Final", _)), Comb (Comb (Const ("Face", _), ys), Const ("Nonfinal", _)) ->
        INST[xs, var_xs_num_list; ys, var_ys_num_list] face_case3
      | Comb (Comb (Const ("Face", _), xs), Const ("Nonfinal", _)), Comb (Comb (Const ("Face", _), ys), Const ("Final", _)) ->
        INST[xs, var_xs_num_list; ys, var_ys_num_list] face_case4
      | Const ("Final", _), Const ("Nonfinal", _) -> facetype_case1
      | Const ("Nonfinal", _), Const ("Final", _) -> facetype_case2
      | _ -> f_EQ_num tm1 tm2
    with
    | Failure msg -> eval_error msg "f_EQ" [tm1; tm2]
    | Eval_error err -> eval_error_propagate err "f_EQ" [tm1; tm2]
     in
  f_EQ;;

module Type_cmp = struct
  type t = hol_type
  let compare (t1:t) (t2:t) = Pervasives.compare t1 t2
end;;

module Term_list_cmp = struct
  type t = term list
  let compare (ts1:t) (ts2:t) = Pervasives.compare ts1 ts2
end;;

module Type_set = Set.Make(Type_cmp);;
module Term_list_set = Set.Make(Term_list_cmp);;

let setify_types tys =
  Type_set.of_list tys |> Type_set.elements;;

let setify_terms tms =
  Term_set.of_list tms |> Term_set.elements;;

let freqs list =
  let table = Hashtbl.create (length list) in
  let count x =
    let v =
      try Hashtbl.find table x 
      with Not_found -> 
        let v = ref 0 in
        Hashtbl.add table x v; v in
    incr v in
  List.iter count list;
  Hashtbl.fold (fun k v r -> (k, !v) :: r) table []
    |> List.sort (fun (_, v1) (_, v2) -> Pervasives.compare v2 v1);;

let analyze_arg_lists () =
  let analyze args =
    let n = List.length args in
    let k = Term_list_set.of_list args |> Term_list_set.cardinal in
    float (n - k) /. float n, n in
  all_arg_lists ()
    |> List.map (fun (name, args) -> name, analyze args)
    |> List.sort (fun (_, (v1, _)) (_, (v2, _)) -> Pervasives.compare v2 v1);;

#load "unix.cma";;

let test n f a =
  let start = Unix.gettimeofday() in
  let r = f a in
  for i = 2 to n do
    ignore (f a)
  done;
  let finish = Unix.gettimeofday() in
  r, finish -. start;;
