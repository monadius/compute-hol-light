#load "str.cma";;

let rec split_while p = function
  | [] -> [], []
  | (x :: xs) as l -> 
    if p x then
      let a, b = split_while p xs in
      x :: a, b
    else
      [], l;;

let rec BODY_CONJUNCTS th =
  if is_forall (concl th) then
    BODY_CONJUNCTS (SPEC_ALL th)
  else if is_conj (concl th) then
    BODY_CONJUNCTS (CONJUNCT1 th) @ BODY_CONJUNCTS (CONJUNCT2 th)
  else [th];;

let eq_intro thm =
  if is_eq (concl thm) then thm else
  if is_neg (concl thm) then EQF_INTRO thm
  else EQT_INTRO thm;;
  
let split_thm th =
  List.map eq_intro (BODY_CONJUNCTS th);;

let fix_name, clear_fixes, add_fix_repl =
  let repls = ref [] in
  let clear () = repls := [] in
  let add_repl str repl =
    let re = Str.regexp_string str in
    repls := List.stable_sort (fun (s1, _, _) (s2, _, _) -> String.length s2 - String.length s1) 
                              ((str, re, repl) :: !repls) in
  let fix name =
    List.fold_left (fun s (_, re, repl) -> Str.global_replace re repl s) name !repls in
  fix, clear, add_repl;;

(* Standard names for common symbols *)
let () =
  clear_fixes();
  List.iter (uncurry add_fix_repl) [
    "+", "ADD";
    "-", "SUB";
    "*", "MUL";
    "/", "DIV";
    "<", "LT";
    ">", "GT";
    "<=", "LE";
    ">=", "GE";
    "=", "EQ";
];;

type arg_type =
    Ttype of hol_type
  | Tfun of arg_type list * hol_type;;

let get_type =
  let rec get ty =
    match splitlist dest_fun_ty ty with
    | [], t -> Ttype t
    | tys, t -> Tfun (map get tys, t) in
  fun tm ->
    get (type_of tm);;

type pattern = 
    Pvar of int
  | Papp of term * pattern list;;

let check_arg_form tm =
  let rec chk t stk free =
    if is_comb t then
      let rator, rand = dest_comb t in
      let free', pat1 = chk rand [] free in
      chk rator (pat1 :: stk) free'
    else if is_var t then
      if stk = [] then
        let newi = List.length free in
        try (free, Pvar (newi - index t free - 1))
        with _ -> (t :: free, Pvar newi)
      else 
        failwith ("check_arg_form: " ^ fst (dest_var t) ^ " occurs as a variable on lhs")
    else if is_const t then
      (free, Papp (t, stk))
    else
      failwith ("check_arg_form: lambda abstraction not allowed on lhs") 
  in
  match chk tm [] [] with
    | (fv, Papp (head, args)) -> (List.rev fv, head, args)
    | _ -> failwith "check_arg_form: ill-formed lhs";;


type rewrite_rec = {
  args: pattern list;
  arg_types: arg_type list;
  fv: term list;
  thm_name: string;
  thm_index: int;
  thm: thm;
};;

type db_rec = {
  f_name: string;
  const: term;
  nargs: int;
  mutable rewrites: rewrite_rec list;
};;

let entries db = Hashtbl.fold (fun name e r -> (name, e) :: r) db [];;

let empty_db () = (Hashtbl.create 100 : (string, db_rec) Hashtbl.t);;

let add_thm db (thm_name, index, eq_th) =
  let lhs, rhs = dest_eq (concl eq_th) in
  let fv, cst, arg_pats = check_arg_form lhs in
  let name, _ = dest_const cst in
  let entry =
    try Hashtbl.find db name
    with Not_found -> 
      let e = {
        f_name = "f_" ^ fix_name name;
        const = cst;
        nargs = List.length arg_pats;
        rewrites = [];
      } in
      Hashtbl.add db name e; e in
  if entry.nargs <> List.length arg_pats then
    failwith (Format.sprintf "Incorrect number of arguments for '%s' in '%s'" 
                             name (string_of_thm eq_th));
  entry.rewrites <- { 
    args = arg_pats;
    arg_types = map get_type @@ snd (strip_comb lhs);
    fv = fv;
    thm = eq_th;
    thm_name = thm_name;
    thm_index = index;
  } :: entry.rewrites;;

let add_thms db ths =
  let add (name, th) =
    let eqs = split_thm th in
    List.iteri (fun i th -> add_thm db (name, i + 1, th)) eqs in
  List.iter add ths;
  db;;

type app_type = Basic_app of term | Const_app of db_rec | Var_app of string;;

type eval_tree =
    Refl of term
  | Func_app of app_type * eval_tree list
  | Partial_app of app_type * eval_tree list * int;;

let is_eval_tree_refl = function
  | Refl _ -> true
  | _ -> false;;

let is_basic_app = function
  | Func_app (Basic_app _, _) | Partial_app (Basic_app _, _, _) -> true
  | _ -> false;;

let build_eval_tree db =
  let mk_app head args =
    let app_type =
      match head with
      | Var (name, _) -> Var_app name
      | Const (name, _) -> begin
          try Const_app (Hashtbl.find db name)
          with Not_found -> Basic_app head
        end
      | _ -> failwith "mk_app: head should be a variable or a constant" in
    match get_type head with
    | Tfun (l, _) ->
      let n = List.length l - List.length args in
      if n > 0 then
        Partial_app (app_type, args, n)
      else
        Func_app (app_type, args)
    | _ -> failwith "mk_app: head should be a function" in
  let rec build tm =
    match tm with
    | Comb _ ->
      let op, args = strip_comb tm in
      let arg_trees = List.map build args in
      mk_app op arg_trees
    | _ -> (try mk_app tm [] with Failure _ -> Refl tm)
  in
  build;;

let rec optimize_eval_tree = function
  | Refl _ as t -> t
  | Func_app (Basic_app head, args) | Partial_app (Basic_app head, args, _) ->
    let args' = List.map optimize_eval_tree args in
    let refls, rest = split_while is_eval_tree_refl args' in
    let tm = List.fold_left (curry mk_comb) head
      (List.map (function Refl t -> t | _ -> failwith "impossible") refls) in
    if rest = [] then
      Refl tm
    else
      Func_app (Basic_app tm, rest)
  | Func_app (t, args) -> 
    Func_app (t, List.map optimize_eval_tree args)
  | Partial_app (t, args, extra) ->
    Partial_app (t, List.map optimize_eval_tree args, extra);;


type expr =
  | Match of expr * (expr * expr) list
  | Lambda of string list * expr
  | Tuple of expr list
  | Let of bool * string * string list * expr * expr option
  | If of expr * expr * expr
  | App of expr * expr
  | Term of term
  | String of string
  | Raw of string;;

let is_app = function App _ -> true | _ -> false;;

let is_let = function Let _ -> true | _ -> false;;

let is_match = function Match _ -> true | _ -> false;;

let is_compound = function
  | Let _ | Match _ | Lambda _ -> true
  | _ -> false;;

let mk_app (head, args) =
  List.fold_left (fun e a -> App (e, a)) head args;;

let mk_raw s = Raw s;;

let mk_tuple = function
  | [] -> Raw "()"
  | [e] -> e
  | es -> Tuple es;;

let mk_let ?(args = []) ?(body = None) (name, expr) =
  Let (false, name, args, expr, body);;

let rec chain_let = function
  | [e] -> e
  | Let (r, a, b, e, _) :: es ->
    Let (r, a, b, e, Some (chain_let es))
  | _ -> failwith "chain_let";;

let rec append_let_body let_e body =
  match let_e with
  | Let (r, a, b, e, None) -> Let (r, a, b, e, Some body)
  | Let (r, a, b, e, Some n) -> Let (r, a, b, e, Some (append_let_body n body))
  | _ -> failwith "append_let_body";;

let enum_names s n =
  List.map (fun k -> s ^ string_of_int k) (1 -- n);;

let compile_rhs db rw =
  let mk_refl expr = App (Raw "REFL", expr) in
  let mk_comb op_name args =
    List.fold_left 
      (fun eq (r, arg_eq) -> 
        App (Raw "MK_COMB", mk_tuple [eq; if r then mk_refl arg_eq else arg_eq]))
      (mk_refl (Raw op_name)) args in
  let dest_comb tm_name names =
    let rec dest prev names =
      match names with
      | [] -> []
      | name :: names ->
        mk_let (Format.sprintf "op, %s" name, App (Raw "dest_comb", Raw prev)) ::
          dest "op" names in
    dest tm_name (List.rev names) in
  let compile_cond name cond_expr then_expr else_expr =
    let type_expr = mk_let ("ty", App (Raw "type_of", Raw "then_tm")) in
    let t_var = mk_let ("then_var", App (Raw "mk_var", mk_tuple [String "t"; Raw "ty"])) in
    let e_var = mk_let ("else_var", App (Raw "mk_var", mk_tuple [String "e"; Raw "ty"])) in
    let cond_eq = mk_let ("cond_eq", cond_expr) in
    let cond_th =
      mk_let ("th0", mk_comb "op" [false, Raw "cond_eq"; true, Raw "then_tm"; true, Raw "else_tm"]) in
    let then_branch = chain_let [
      mk_let ("th1", Raw "INST[then_tm, then_var; else_tm, else_var] (INST_TYPE[ty, aty] COND_T)");
      mk_let ("then_eq", then_expr);
      Raw "TRANS (TRANS th0 th1) then_eq"
    ] in
    let else_branch = chain_let [
      mk_let ("th1", Raw "INST[then_tm, then_var; else_tm, else_var] (INST_TYPE[ty, aty] COND_F)");
      mk_let ("else_eq", else_expr);
      Raw "TRANS (TRANS th0 th1) else_eq"
    ] in
    let cond_test = Raw "rand (concl cond_eq) = true_tm" in
    let if_expr = If (cond_test, then_branch, else_branch) in
    chain_let (dest_comb name ["cond_tm"; "then_tm"; "else_tm"] @ 
      [type_expr; t_var; e_var; cond_eq; cond_th; if_expr]) in
  let rec code name t =
    match t with
    | Refl _ -> mk_refl (Raw name)
    | Func_app (Basic_app (Const ("COND", _)), [cond_arg; then_arg; else_arg]) ->
      compile_cond name (code "cond_tm" cond_arg) (code "then_tm" then_arg) (code "else_tm" else_arg)
    | Partial_app (app_type, [], _) ->
      let f_name = 
        (match app_type with
        | Var_app name -> name
        | Const_app rw -> rw.f_name
        | _ -> failwith "Partial_app (Basic_app) is not allowed") in
      mk_tuple [Raw "op"; Raw f_name]
    | Partial_app (app_type, args, extra_args) ->
      Raw "partial"
    | Func_app (app_type, args) ->
    begin
      let n = List.length args in
      let arg_names = enum_names "a" n in
      let arg_code = map2 code arg_names args in
      let arg_list = map2 (fun a name -> is_eval_tree_refl a, mk_raw name) args arg_names in
      let final = 
        match app_type with
        | Basic_app tm -> mk_comb "op" arg_list
        | Const_app f ->
          let args' = map (fun (r, a) -> 
            if r then a else App (Raw "rand", App (Raw "concl", a))) arg_list in
          let app_expr = mk_app (Raw f.f_name, args') in
          if forall fst arg_list then app_expr
          else
            let e1 = mk_let ("f_eq", mk_app (Raw f.f_name, args')) in
            let e2 = mk_comb "op" arg_list in
            let e3 = mk_app (Raw "TRANS", [e2; Raw "f_eq"]) in
            append_let_body e1 e3
        | Var_app v ->
          Raw (Format.sprintf "F_LEFT %s [%s]" v ""(*arg_list*)) in
      let arg_eq =
        itlist2 (fun (name, (r, _)) expr body ->
          if r then body else Let (false, name, [], expr, Some body))
        (zip arg_names arg_list) arg_code final in
      chain_let (dest_comb name arg_names @ [arg_eq])
    end
  in
  let inst = 
    List.map (fun tm -> 
      let name, _ = dest_var tm in
      name, name ^ "_var") rw.fv in
  let th_name = Format.sprintf "%s_case%d" rw.thm_name rw.thm_index in
  let inst_expr =
    if inst = [] then Raw th_name
    else
      let inst_str = Format.sprintf "[%s]" 
        (String.concat "; " (map (fun (a, b) -> a ^ ", " ^ b) inst)) in
      App (App (Raw "INST", Raw inst_str), Raw th_name) in
  let rhs = (snd o dest_eq o concl) rw.thm in
  let eval_tree = build_eval_tree db rhs |> optimize_eval_tree in
  if is_eval_tree_refl eval_tree then
    inst_expr
  else
    let expr = code "rhs" eval_tree in
    chain_let [
      mk_let ("th", inst_expr);
      mk_let ("rhs", Raw "rand (concl th)");
      mk_let ("rhs_eq", expr);
      mk_app (Raw "TRANS", [Raw "th"; Raw "rhs_eq"])
    ];;


let compile_case db case =
  let var_name i = fst (dest_var (List.nth case.fv i)) in
  let rec compile_pat = function
    | Pvar i, Tfun (args, _) -> mk_tuple [Raw (var_name i); Raw (var_name i ^ "_func")]
    | Pvar i, _ -> Raw (var_name i)
    | Papp _, Tfun _ -> failwith "Patterns are not allowed for functions"
    | Papp (c, ps), ty ->
      let c_name, _ = dest_const c in
      let cst = App (Raw "Const", mk_tuple [String c_name; Raw "_"]) in
      List.fold_left (fun l r -> App (Raw "Comb", Tuple [l; r])) cst 
        (List.map (fun p -> compile_pat (p, ty)) ps)
  in
  let pat = mk_tuple (List.map compile_pat (zip case.args case.arg_types)) in
  let body = compile_rhs db case in
  pat, body;;

let compile_prelude rw =
  let max_index name =
    List.filter (fun r -> r.thm_name = name) rw.rewrites
      |> List.fold_left (fun m r -> max m r.thm_index) 0 in
  let get_thms name =
    let n = max_index name in
    let names = enum_names (name ^ "_case") n in
    let pat_names = enum_names "th" n in
    mk_let (String.concat ", " names,
      Match (App (Raw "split_thm", Raw name),
        [Raw ("[" ^ String.concat "; " pat_names ^ "]"), mk_tuple (List.map mk_raw pat_names);
         Raw "_", Raw "failwith \"error\""])) in
  let get_var tm =
    let name, ty = dest_var tm in
    let ty_str = Format.sprintf "`:%s`" (string_of_type ty) in
    mk_let (name ^ "_var", App (Raw "mk_var", mk_tuple [String name; Raw ty_str])) in
  let names = setify (map (fun r -> r.thm_name) rw.rewrites) in
  let th_exprs = map get_thms names in
  let vars = map (fun r -> r.fv) rw.rewrites |> flat |> setify in
  let var_exprs = map get_var vars in
  var_exprs @ th_exprs |> chain_let;;


let compile db rw =
  let c_name, _ = dest_const rw.const in
  let arg_names = enum_names "tm" rw.nargs in
  let err_pat = 
    (Raw "_", App (Raw "failwith", String (Format.sprintf "No match: %s" c_name))) in
  let match_e = Match (mk_tuple (List.map mk_raw arg_names), 
                     List.map (compile_case db) rw.rewrites @ [err_pat]) in
  let top_e = Let (true, rw.f_name, arg_names, match_e, Some (Raw rw.f_name)) in
  let prelude = append_let_body (compile_prelude rw) top_e in
  Let (false, rw.f_name, [], prelude, None);;



let rec print_expr fmt = function
  | Raw s -> Format.fprintf fmt "%s" s
  | String s -> Format.fprintf fmt "\"%s\"" s
  | Term tm -> Format.fprintf fmt "`%s`" (string_of_term tm)
  | Tuple es -> 
    Format.fprintf fmt "(%a)" 
      (Format.pp_print_list 
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt ", ")
        print_expr) es
  | Lambda (vars, body) ->
    Format.fprintf fmt "@[<v 2>fun %s ->@,%a@]"
      (String.concat " " vars) print_expr body
  | If (c, t, e) ->
    Format.fprintf fmt "@[<v 2>if %a then@ %a@;<1 -2>else@ %a@]"
      print_expr c print_expr t print_expr e
  | App (f, x) ->
    let f1 = format_of_string "%a" in
    let f2 = format_of_string (if is_app x then " (%a)" else " %a") in
    Format.fprintf fmt (f1 ^^ f2) print_expr f print_expr x
  | Let (r, name, arg_names, expr, None) ->
    Format.fprintf fmt "@[<v 2>let%s %s %s=@,%a@]"
      (if r then " rec" else "")
      name (if arg_names = [] then "" else String.concat " " arg_names ^ " ")
      print_expr expr
  | Let (r, name, arg_names, expr, Some body) ->
    let f = format_of_string 
      (if is_compound expr then
        "@[<v 2>let%s %s %s=@ %a in@]@ %a"
      else
        "@[<hv 2>let%s %s %s=@ %a in@]@ %a") in
    Format.fprintf fmt f
        (if r then " rec" else "")
        name (if arg_names = [] then "" else String.concat " " arg_names ^ " ")
        print_expr expr print_expr body
  | Match (expr, cases) ->
    Format.fprintf fmt "match %a with@,| %a"
      print_expr expr
      (Format.pp_print_list 
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt "| ")
        (fun fmt (pat, body) ->
          let f = format_of_string 
            (if is_compound body then
              "@[<v>%a ->@ %a@]@,"
             else
              "@[<hv>%a ->@ %a@]@,") in
          Format.fprintf fmt f
            print_expr pat print_expr body)) cases;;
