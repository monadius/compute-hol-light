let rec BODY_CONJUNCTS th =
  if is_forall (concl th) then
    BODY_CONJUNCTS (SPEC_ALL th)
  else if is_conj (concl th) then
    BODY_CONJUNCTS (CONJUNCT1 th) @ BODY_CONJUNCTS (CONJUNCT2 th)
  else [th];;

type pattern = 
    Pvar of int
  | Papp of term * pattern list;;

let check_arg_form tm =
  let rec chk t stk free =
    if is_comb t then
      let rator, rand = dest_comb t in
      let free', pat1 = chk rand [] free in
      chk rator (pat1 :: stk) free'
    else if is_var t then
      if stk = [] then
        let newi = List.length free in
        try (free, Pvar (newi - index t free - 1))
        with _ -> (t :: free, Pvar newi)
      else 
        failwith ("check_arg_form: " ^ fst (dest_var t) ^ " occurs as a variable on lhs")
    else if is_const t then
      (free, Papp (t, List.rev stk))
    else
      failwith ("check_arg_form: lambda abstraction not allowed on lhs") 
  in
  match chk tm [] [] with
    | (fv, Papp (head, args)) -> (List.rev fv, head, args)
    | _ -> failwith "check_arg_form: ill-formed lhs";;

type rewrite_rec = {
  args: pattern list;
  fv: term list;
  thm: thm;
};;

type db_rec = {
  f_name: string;
  const: term;
  nargs: int;
  mutable rewrites: rewrite_rec list;
};;

let entries db = Hashtbl.fold (fun name e r -> (name, e) :: r) db [];;

let empty_db () = (Hashtbl.create 100 : (string, db_rec) Hashtbl.t);;

let add_thm db eq_th =
  let lhs, rhs = dest_eq (concl eq_th) in
  let fv, cst, arg_pats = check_arg_form lhs in
  let name, _ = dest_const cst in
  let entry = 
    try Hashtbl.find db name
    with Not_found -> 
      let e = {
        f_name = "f_" ^ name;
        const = cst;
        nargs = List.length arg_pats;
        rewrites = [];
      } in
      Hashtbl.add db name e; e in
  if entry.nargs <> List.length arg_pats then
    failwith (Format.sprintf "Incorrect number of arguments for '%s' in '%s'" 
                             name (string_of_thm eq_th));
  entry.rewrites <- { args = arg_pats; fv = fv; thm = eq_th } :: entry.rewrites;;

let add_thms db ths =
  List.iter (List.iter (add_thm db) o BODY_CONJUNCTS) ths;
  db;;

type eval_tree =
    Refl
  | Basic_app of term * eval_tree list
  | F_app of db_rec * eval_tree list
  | Var_app of string * eval_tree list;;

let is_eval_tree_refl = function
  | Refl -> true
  | _ -> false;;

let eval_n_args = function
  | Basic_app (_, l) | F_app (_, l) | Var_app (_, l) -> List.length l
  | _ -> failwith "eval_n_args";;

let build_eval_tree db =
  let rec build tm =
    match tm with
    | Comb _ ->
      let op, args = strip_comb tm in
      let arg_trees = List.map build args in
      if is_var op then
        Var_app (fst (dest_var op), arg_trees)
      else
        let name, _ = dest_const op in
        begin
          try
            let app = Hashtbl.find db name in
            F_app (app, arg_trees)
          with Not_found ->
            Basic_app (tm, arg_trees)
        end
    | _ -> Refl
  in
  build;;

let rec optimize_eval_tree = function
  | Refl -> Refl
  | F_app (op, args) ->
    let trees = List.map optimize_eval_tree args in
    F_app (op, trees)
  | Var_app (name, args) ->
    let trees = List.map optimize_eval_tree args in
    Var_app (name, trees)
  | Basic_app (tm, args) ->
    let trees = List.map optimize_eval_tree args in
    if forall is_eval_tree_refl trees then
      Refl
    else
      Basic_app (tm, trees);;



type expr =
  | Match of expr * (expr * expr) list
  | Tuple of expr list
  | Let of string * string list * expr * expr option
  | App of expr * expr
  | Term of term
  | String of string
  | Raw of string;;

let is_app = function App _ -> true | _ -> false;;

let mk_app a b = App (a, b);;

let mk_raw s = Raw s;;

let mk_tuple = function
  | [] -> Raw "()"
  | [e] -> e
  | es -> Tuple es;;

let enum_names s n =
  List.map (fun k -> s ^ string_of_int k) (1 -- n);;

let compile_rhs db rw =
  let rhs = (snd o dest_eq o concl) rw.thm in
  let eval_tree = build_eval_tree db rhs |> optimize_eval_tree in

  let rec code name t =
    match t with
    | Refl -> App (Raw "REFL", Raw name)
    | Basic_app (_, args) | F_app (_, args) | Var_app (_, args) -> 
    begin
      let n = List.length args in
      let arg_names = enum_names "a" n in
      let arg_code = map2 code arg_names args in
      let arg_list = String.concat "; " arg_names in
      let final = 
        match t with
        | Basic_app (tm, _) -> 
          Raw (Format.sprintf "AP_LEFT op [%s]" arg_list)
        | F_app (f, _) ->
          Raw (Format.sprintf "F_LEFT %s [%s]" f.f_name arg_list)
        | Var_app (v, _) ->
          Raw (Format.sprintf "F_LEFT %s [%s]" v arg_list)
        | _ -> failwith "t" in
      let arg_eq =
        itlist2 (fun a c body -> Let (a, [], c, Some body)) arg_names arg_code final in
      Let ("op, a1", [], App (Raw "dest_comb", Raw name), Some arg_eq)
    end
  in
  code "rhs" eval_tree;;


let compile_case db case =
  let rec compile_pat pat =
    match pat with
    | Pvar i -> Raw ((fst o dest_var o List.nth case.fv) i)
    | Papp (c, ps) ->
      let c_name, _ = dest_const c in
      let cst = App (Raw "Const", Tuple [String c_name; Raw "_"]) in
      List.fold_left (fun l r -> App (Raw "Comb", Tuple [l; r])) cst (List.map compile_pat ps)
  in
  let pat = mk_tuple (List.map compile_pat case.args) in
  let body = compile_rhs db case in
  pat, body;;

let compile db rw =
  let c_name, _ = dest_const rw.const in
  let f_name = "f_" ^ c_name in
  let arg_names = enum_names "tm" rw.nargs in
  let err_pat = 
    (Raw "_", App (Raw "failwith", String (Format.sprintf "No match: %s" c_name))) in
  let top_e = Match (mk_tuple (List.map mk_raw arg_names), 
                     List.map (compile_case db) rw.rewrites @ [err_pat]) in
  Let (f_name, arg_names, top_e, None);;



let rec print_expr fmt = function
  | Raw s -> Format.fprintf fmt "%s" s
  | String s -> Format.fprintf fmt "\"%s\"" s
  | Term tm -> Format.fprintf fmt "`%s`" (string_of_term tm)
  | Tuple es -> 
    Format.fprintf fmt "(%a)" 
      (Format.pp_print_list 
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt ", ")
        print_expr) es
  | App (f, x) ->
    let f1 = format_of_string (if is_app f then "(%a)" else "%a") in
    let f2 = format_of_string (if is_app x then " (%a)" else " %a") in
    Format.fprintf fmt (f1 ^^ f2) print_expr f print_expr x
  | Let (name, arg_names, expr, None) ->
    Format.fprintf fmt "@[<v 2>let rec %s %a =@,%a@]"
      name (Format.pp_print_list Format.pp_print_string) arg_names 
      print_expr expr
  | Let (name, arg_names, expr, Some body) ->
      Format.fprintf fmt "@[<v 2>let %s %a =@,%a in@]@ %a"
        name (Format.pp_print_list Format.pp_print_string) arg_names 
        print_expr expr print_expr body
  | Match (expr, cases) ->
    Format.fprintf fmt "match %a with@,| %a@,"
      print_expr expr
      (Format.pp_print_list 
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt "| ")
        (fun fmt (pat, body) -> 
          Format.fprintf fmt "@[<v>%a -> @,%a@]@,"
            print_expr pat print_expr body)) cases;;


let db = add_thms (empty_db ()) [ARITH_SUC];;
entries db;;
let r = entries db |> hd |> snd;;
let c = compile_rhs db (hd (r.rewrites));;
print_expr Format.std_formatter c;;

let r = entries db |> hd |> snd |> compile db;;
print_expr Format.std_formatter r;;



let [th0; th1; th2; th3] = BODY_CONJUNCTS ARITH_SUC;;
let n_var = `n:num`;;

let AP_LEFT tm eq_ths =
  List.fold_left (curry MK_COMB) (REFL tm) eq_ths;;

let suc_tm = `SUC`;;

let F_LEFT f eq_ths =
  match eq_ths with
  | [eq_th] ->
    let rhs = rand (concl eq_th) in
    let f_th = f rhs in
    TRANS (AP_TERM suc_tm eq_th) f_th
  | _ -> failwith "F_LEFT";;

let rec f_SUC tm1 =
  match tm1 with
  | Comb (Const ("BIT1", _), n) ->
    let th = INST [n, n_var] th3 in
    let rhs = rand (concl th) in
    let op, a1  =
      dest_comb rhs in
    let a1  =
      let op, a1  =
        dest_comb a1 in
      let a1  =
        REFL a1 in
      F_LEFT f_SUC [a1] in
    TRANS th (AP_LEFT op [a1])
  | Comb (Const ("BIT0", _), n) ->
    let th = INST [n, n_var] th2 in
    let rhs = rand (concl th) in
    TRANS th (REFL rhs)
  | Const ("_0", _) ->
    let th = th1 in
    let rhs = rand (concl th) in
    TRANS th (REFL rhs)
  | Comb (Const ("NUMERAL", _), n) ->
    let th = INST [n, n_var] th0 in
    let rhs = rand (concl th) in
    let op, a1  =
      dest_comb rhs in
    let a1  =
      let op, a1  =
        dest_comb a1 in
      let a1  =
        REFL a1 in
      F_LEFT f_SUC [a1] in
    TRANS th (AP_LEFT op [a1])
  | _ ->
    failwith "No match: SUC";;

let rec f_SUC tm1 =
  match tm1 with
  | Comb (Const ("BIT1", _), n) ->
    let th = INST [n, n_var] th3 in
    let rhs = rand (concl th) in
    let op, a1  =
      dest_comb rhs in
    let a1  =
      let op, a1  =
        dest_comb a1 in
      f_SUC a1 in
    TRANS th (AP_TERM op a1)
  | Comb (Const ("BIT0", _), n) ->
    INST [n, n_var] th2
  | Const ("_0", _) -> 
    th1
  | Comb (Const ("NUMERAL", _), n) ->
    let th = INST [n, n_var] th0 in
    let rhs = rand (concl th) in
    let op, a1  =
      dest_comb rhs in
    let a1  =
      let op, a1  =
        dest_comb a1 in
      f_SUC a1 in
    TRANS th (AP_TERM op a1)
  | _ ->
    failwith "No match: SUC";;

#load "unix.cma";;

let test f n a =
  let start = Unix.gettimeofday() in
  let r = f a in
  for i = 1 to n do
    ignore (f a)
  done;
  let finish = Unix.gettimeofday() in
  r, finish -. start;;
test f_SUC 10000 `259`;;
test NUM_SUC_CONV 10000 `SUC 259`;;