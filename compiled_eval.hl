#load "str.cma";;

(* A performance improvement trick from calc_num.ml *)
let standardize, standardize_tm, standardize_list, standardize_reset =
  let cache = Hashtbl.create 100 in
  let find t = 
    try Hashtbl.find cache t 
    with Not_found -> Hashtbl.add cache t t; t in
  let rec replace tm =
    match tm with
    | Var _ | Const _ -> find tm
    | Comb (s, t) -> (* find @@*) mk_comb (replace s, replace t)
    | Abs (v, b) -> (* find @@*) mk_abs (replace v, replace b) in
  let st th =
    let concl' = replace (concl th) in
    EQ_MP (REFL concl') th in
  let get () = Hashtbl.fold (fun _ t ts -> t :: ts) cache [] in
  let reset () = Hashtbl.clear cache in
    st, replace, get, reset;;

let rec split_while p = function
  | [] -> [], []
  | (x :: xs) as l -> 
    if p x then
      let a, b = split_while p xs in
      x :: a, b
    else
      [], l;;

let rec GEN_BETAS_CONV tm = 
  (GEN_BETA_CONV ORELSEC (RATOR_CONV GEN_BETAS_CONV THENC GEN_BETA_CONV)) tm;;

let rec BODY_CONJUNCTS th =
  if is_forall (concl th) then
    BODY_CONJUNCTS (SPEC_ALL th)
  else if is_conj (concl th) then
    BODY_CONJUNCTS (CONJUNCT1 th) @ BODY_CONJUNCTS (CONJUNCT2 th)
  else [th];;

let eq_intro thm =
  if is_eq (concl thm) then thm else
  if is_neg (concl thm) then EQF_INTRO thm
  else EQT_INTRO thm;;
  
let split_thm th =
  List.map (standardize o eq_intro) (BODY_CONJUNCTS th);;

let fix_name, clear_fixes, add_fix_repl =
  let repls = ref [] in
  let clear () = repls := [] in
  let add_repl str repl =
    let re = Str.regexp_string str in
    repls := List.stable_sort (fun (s1, _, _) (s2, _, _) -> String.length s2 - String.length s1) 
                              ((str, re, repl) :: !repls) in
  let fix name =
    List.fold_left (fun s (_, re, repl) -> Str.global_replace re repl s) name !repls in
  fix, clear, add_repl;;

(* Standard names for common symbols *)
let () =
  clear_fixes();
  List.iter (uncurry add_fix_repl) [
    "+", "ADD";
    "-", "SUB";
    "*", "MUL";
    "/", "DIV";
    "<", "LT";
    ">", "GT";
    "<=", "LE";
    ">=", "GE";
    "=", "EQ";
];;

type arg_type =
    Ttype of hol_type
  | Tfun of arg_type list * hol_type;;

let get_type =
  let rec get ty =
    match splitlist dest_fun_ty ty with
    | [], t -> Ttype t
    | tys, t -> Tfun (map get tys, t) in
  fun tm ->
    get (type_of tm);;

type pattern = 
    Pvar of int
  | Papp of term * pattern list;;

let check_arg_form, check_args_form =
  let rec chk t stk free =
    if is_comb t then
      let rator, rand = dest_comb t in
      let free', pat1 = chk rand [] free in
      chk rator (pat1 :: stk) free'
    else if is_var t then
      if stk = [] then
        let newi = List.length free in
        try (free, Pvar (newi - index t free - 1))
        with _ -> (t :: free, Pvar newi)
      else 
        failwith ("check_arg_form: " ^ fst (dest_var t) ^ " occurs as a variable on lhs")
    else if is_const t then
      (free, Papp (t, stk))
    else
      failwith ("check_arg_form: lambda abstraction not allowed on lhs") 
  in
  let check_arg_form tm =
    match chk tm [] [] with
      | (fv, Papp (head, args)) -> (List.rev fv, head, args)
      | _ -> failwith "check_arg_form: ill-formed lhs" in
  let check_args_form tms =
    let fv, args =
      List.fold_right (fun arg (fv, args) ->
        let fv', arg' = chk arg [] fv in
        (fv', arg' :: args)) tms ([], []) in
    List.rev fv, args in
  check_arg_form, check_args_form;;


type rewrite_rec = {
  args: pattern list;
  arg_types: arg_type list;
  fv: term list;
  thm_name: string;
  thm_index: int;
  thm: thm;
};;

type db_rec = {
  f_name: string;
  const: term;
  nargs: int;
  mutable rewrites: rewrite_rec list;
};;

let entries db = Hashtbl.fold (fun name e r -> (name, e) :: r) db [];;

let get_entries db names =
  let es = entries db in
  map (fun name -> assoc name es) names;;

let empty_db () = (Hashtbl.create 100 : (string, db_rec) Hashtbl.t);;

let add_thm db (thm_name, index, eq_th) =
  let lhs, rhs = dest_eq (concl eq_th) in
  let fv, cst, arg_pats = check_arg_form lhs in
  let name, _ = dest_const cst in
  let entry =
    try Hashtbl.find db name
    with Not_found -> 
      let e = {
        f_name = "f_" ^ fix_name name;
        const = cst;
        nargs = List.length arg_pats;
        rewrites = [];
      } in
      Hashtbl.add db name e; e in
  if entry.nargs <> List.length arg_pats then
    failwith (Format.sprintf "Incorrect number of arguments for '%s' in '%s'" 
                             name (string_of_thm eq_th));
  entry.rewrites <- { 
    args = arg_pats;
    arg_types = map get_type @@ snd (strip_comb lhs);
    fv = fv;
    thm = eq_th;
    thm_name = thm_name;
    thm_index = index;
  } :: entry.rewrites;;

let add_thms db ths =
  let add (name, th) =
    let eqs = split_thm th in
    List.iteri (fun i th -> add_thm db (name, i + 1, th)) eqs in
  List.iter add ths;
  db;;

type app_arg_type = Arg_term | Arg_theorem | Arg_function;;

type app_type = 
    Basic_app of term 
  | Const_app of db_rec 
  | Var_app of string
  | Abs_app of term * eval_tree

and eval_tree =
    Refl of term
  | Func_app of app_type * eval_tree list
  (* head, args, extra args (we only need to know their types) *)
  | Partial_app of app_type * eval_tree list * app_arg_type list;;

let get_eval_type = function
  | Refl _ -> Arg_term
  | Func_app _ -> Arg_theorem
  | Partial_app _ -> Arg_function;;

let is_eval_tree_refl = function
  | Refl _ -> true
  | _ -> false;;

let is_basic_app = function
  | Func_app (Basic_app _, _) | Partial_app (Basic_app _, _, _) -> true
  | _ -> false;;

let build_eval_tree db =
  let rec mk_app head args =
    let app_type =
      match head with
      | _ when is_gabs head -> 
        let _, body = strip_gabs head in
        Abs_app (head, build body)
      | Var (name, _) -> Var_app name
      | Const (name, _) -> begin
          try Const_app (Hashtbl.find db name)
          with Not_found -> Basic_app head
        end
      | _ -> failwith "mk_app: head should be a variable, a constant, or an abstraction" in
    match get_type head with
    | Tfun (l, _) ->
      let n = List.length l - List.length args in
      if n > 0 then
        let _, extra = chop_list (List.length args) l in
        let tys = List.map (function Tfun _ -> Arg_function | Ttype _ -> Arg_term) extra in
        Partial_app (app_type, args, tys)
      else
        Func_app (app_type, args)
    | _ -> failwith "mk_app: head should be a function"
  and build tm =
    match tm with
    | Comb _ ->
      let op, args = strip_comb tm in
      let op, args =
        match (op, args) with
        | Const ("GABS", _), h :: t -> mk_comb (op, h), t
        | _ -> op, args in
      let arg_trees = List.map build args in
      mk_app op arg_trees
    | _ -> (try mk_app tm [] with Failure _ -> Refl tm)
  in
  build;;

let optimize_eval_tree =
  let split_args head args =
    let refls, rest = split_while is_eval_tree_refl args in
    let head' = List.fold_left (curry mk_comb) head
      (List.map (function Refl t -> t | _ -> failwith "impossible") refls) in
    head', rest in
  let rec optimize = function
    | Refl _ as t -> t
    | Func_app (Basic_app head, args) ->
      let head', args' = split_args head (List.map optimize args) in
      if args' = [] then
        Refl head'
      else
        Func_app (Basic_app head', args')
    | Partial_app (Basic_app head, args, extra) ->
      let head', args' = split_args head (List.map optimize args) in
      Partial_app (Basic_app head', args', extra)
    | Func_app (t, args) ->
      let t' = match t with Abs_app (tm, body) -> Abs_app (tm, optimize body) | _ -> t in
      Func_app (t', List.map optimize args)
    | Partial_app (t, args, extra) ->
      let t' = match t with Abs_app (tm, body) -> Abs_app (tm, optimize body) | _ -> t in
      Partial_app (t', List.map optimize args, extra) in
  optimize;;

let extract_abs (name_index, init_abs) (base_tm, base_name) eval_tree =
  let index = ref name_index in
  let abstractions = ref init_abs in
  let assoc_rewrite tm body =
    try let _, (_, rw, _, _) = find (fun tm2, _ -> tm = tm2) !abstractions in rw
    with _ -> 
      let rw = {
        f_name = (incr index; Format.sprintf "abs_%d" !index);
        const = tm;
        nargs = List.length (fst (strip_gabs tm));
        rewrites = []
      } in
      abstractions := (tm, (body, rw, base_tm, base_name)) :: !abstractions; rw in
  let rec extract = function
    | Func_app (Abs_app (tm, body), args) ->
      let body' = extract body in
      Func_app (Const_app (assoc_rewrite tm body'), map extract args)
    | Partial_app (Abs_app (tm, body), args, extra) ->
      let body' = extract body in
      Partial_app (Const_app (assoc_rewrite tm body'), map extract args, extra)
    | Func_app (t, args) -> Func_app (t, map extract args)
    | Partial_app (t, args, extra) -> Partial_app (t, map extract args, extra)
    | Refl _ as t -> t
  in
  let result = extract eval_tree in
  result, (!index, List.rev !abstractions);;

type expr =
  | Match of expr * (expr * expr) list
  | Lambda of expr list * expr
  | Tuple of expr list
  | List_expr of expr list
  | Let of bool * string * expr list * expr * expr option
  | Let_and of expr list * expr option
  | If of expr * expr * expr
  | App of expr * expr
  | Term of term
  | String of string
  | Raw of string;;

let is_app = function App _ -> true | _ -> false;;

let is_let = function Let _ -> true | _ -> false;;

let is_match = function Match _ -> true | _ -> false;;

let is_compound = function
  | Let _ | Let_and _ | Match _ | Lambda _ -> true
  | _ -> false;;

let mk_app (head, args) =
  List.fold_left (fun e a -> App (e, a)) head args;;

let mk_raw s = Raw s;;

let mk_tuple = function
  | [] -> Raw "()"
  | [e] -> e
  | es -> Tuple es;;

let mk_list exprs = List_expr exprs;;

let mk_let_and ?(body = None) = function
  | [] -> failwith "mk_let_and: empty list"
  | exprs when forall is_let exprs -> Let_and (exprs, body)
  | _ -> failwith "mk_let_and: all expressions must be let-expressions";;

let mk_let ?(args = []) ?(body = None) (name, expr) =
  Let (false, name, args, expr, body);;

let rec chain_let = function
  | [e] -> e
  | Let (r, a, b, e, _) :: es ->
    Let (r, a, b, e, Some (chain_let es))
  | Let_and (exprs, _) :: es ->
    Let_and (exprs, Some (chain_let es))
  | _ -> failwith "chain_let";;

let rec append_let_body let_e body =
  match let_e with
  | Let_and (exprs, None) -> Let_and (exprs, Some body)
  | Let_and (exprs, Some n) -> Let_and (exprs, Some (append_let_body n body))
  | Let (r, a, b, e, None) -> Let (r, a, b, e, Some body)
  | Let (r, a, b, e, Some n) -> Let (r, a, b, e, Some (append_let_body n body))
  | _ -> failwith "append_let_body";;

let print_expr =
  let let_form and_flag rec_flag =
    match and_flag, rec_flag with
    | true, _ -> "and"
    | _, true -> "let rec"
    | _ -> "let" in
  let rec print_args fmt =
    Format.pp_print_list ~pp_sep:(fun fmt () -> Format.pp_print_string fmt " ") print_expr fmt
  and print_let and_flag fmt = function
    | Let (r, name, args, expr, None) ->
      Format.fprintf fmt "@[<v 2>%s %s %a%s=@ %a@]@ "
        (let_form and_flag r) name 
        print_args args (if args = [] then "" else " ")
        print_expr expr
    | Let (r, name, args, expr, Some body) ->
      let f = format_of_string 
        (if is_compound expr then
          "@[<v 2>let%s %s %a%s=@ %a in@]@ %a"
        else
          "@[<hv 2>let%s %s %a%s=@ %a in@]@ %a") in
      Format.fprintf fmt f
          (if r then " rec" else "") name
          print_args args (if args = [] then "" else " ")
          print_expr expr print_expr body
    | _ -> failwith "print_let: Let expected"
  and print_expr fmt = function
  | Raw s -> Format.fprintf fmt "%s" s
  | String s -> Format.fprintf fmt "\"%s\"" s
  | Term tm -> Format.fprintf fmt "`%s`" (string_of_term tm)
  | Tuple es -> 
    Format.fprintf fmt "(%a)" 
      (Format.pp_print_list 
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt ", ")
        print_expr) es
  | List_expr es ->
    Format.fprintf fmt "[%a]"
      (Format.pp_print_list
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt "; ")
        print_expr) es
  | Lambda (args, body) ->
    Format.fprintf fmt "@[<v 2>fun %a ->@,%a@]"
      print_args args print_expr body
  | If (c, t, e) ->
    Format.fprintf fmt "@[<v 2>if %a then@ %a@;<1 -2>else@ %a@]"
      print_expr c print_expr t print_expr e
  | App (f, x) ->
    let f1 = format_of_string "%a" in
    let f2 = format_of_string (if is_app x then " (%a)" else " %a") in
    Format.fprintf fmt (f1 ^^ f2) print_expr f print_expr x
  | Let _ as expr -> print_let false fmt expr
  | Let_and (expr1 :: exprs, None) ->
    Format.fprintf fmt "@[<v>%a%a@]"
      (print_let false) expr1
      (Format.pp_print_list ~pp_sep:(fun fmt () -> ()) (print_let true)) exprs
  | Let_and (expr1 :: exprs, Some body) ->
    Format.fprintf fmt "@[<v>%a%a in@]@ %a"
      (print_let false) expr1
      (Format.pp_print_list ~pp_sep:(fun fmt () -> ()) (print_let true)) exprs
      print_expr body
  | Let_and _ -> failwith "Let_and: empty list"
  | Match (expr, cases) ->
    Format.fprintf fmt "match %a with@,| %a"
      print_expr expr
      (Format.pp_print_list 
        ~pp_sep:(fun fmt () -> Format.pp_print_string fmt "| ")
        (fun fmt (pat, body) ->
          let f = format_of_string 
            (if is_compound body then
              "@[<v>%a ->@ %a@]@,"
             else
              "@[<hv>%a ->@ %a@]@,") in
          Format.fprintf fmt f
            print_expr pat print_expr body)) cases in
  print_expr;;

let enum_names s n =
  List.map (fun k -> s ^ string_of_int k) (1 -- n);;

let compile_eval_tree =
  let mk_refl expr = App (Raw "REFL", expr) in
  let mk_comb op_name args =
    let comb eq (arg_name, arg_type) =
      let arg_expr = Raw arg_name in
      let arg_eq =
        match arg_type with
        | Arg_term -> mk_refl arg_expr
        | Arg_theorem -> arg_expr
        | Arg_function -> mk_refl (App (Raw "fst", arg_expr)) in
      App (Raw "MK_COMB", mk_tuple [eq; arg_eq]) in
    List.fold_left comb (mk_refl (Raw op_name)) args 
  in
  let dest_comb tm_name names =
    let rec dest prev names =
      match names with
      | [] -> []
      | name :: names ->
        mk_let (Format.sprintf "op, %s" name, App (Raw "dest_comb", Raw prev)) ::
          dest "op" names in
    if names = [] then [mk_let ("op", Raw tm_name)]
    else dest tm_name (List.rev names) 
  in
  let compile_cond name cond_expr then_expr else_expr =
    let type_expr = mk_let ("ty", App (Raw "type_of", Raw "then_tm")) in
    let t_var = mk_let ("then_var", App (Raw "mk_var", mk_tuple [String "t"; Raw "ty"])) in
    let e_var = mk_let ("else_var", App (Raw "mk_var", mk_tuple [String "e"; Raw "ty"])) in
    let cond_eq = mk_let ("cond_eq", cond_expr) in
    let cond_th =
      mk_let ("th0", mk_comb "op" ["cond_eq", Arg_theorem; "then_tm", Arg_term; "else_tm", Arg_term]) in
    let then_branch = chain_let [
      mk_let ("th1", Raw "INST[then_tm, then_var; else_tm, else_var] (INST_TYPE[ty, aty] COND_T)");
      mk_let ("then_eq", then_expr);
      Raw "TRANS (TRANS th0 th1) then_eq"
    ] in
    let else_branch = chain_let [
      mk_let ("th1", Raw "INST[then_tm, then_var; else_tm, else_var] (INST_TYPE[ty, aty] COND_F)");
      mk_let ("else_eq", else_expr);
      Raw "TRANS (TRANS th0 th1) else_eq"
    ] in
    let cond_test = Raw "rand (concl cond_eq) = true_tm" in
    let if_expr = If (cond_test, then_branch, else_branch) in
    chain_let (dest_comb name ["cond_tm"; "then_tm"; "else_tm"] @ 
      [type_expr; t_var; e_var; cond_eq; cond_th; if_expr])
  in
  let compile_app compile name app_type args extra_args =
    let arg_names = enum_names "a" (List.length args) in
    let extra_names = enum_names "tm" (List.length extra_args) in
    let arg_list = map2 (fun name arg -> name, get_eval_type arg) arg_names args in
    let full_arg_list = arg_list @ map2 (fun name ty -> name, ty) extra_names extra_args in
    let extract_arg (arg_name, arg_type) =
      match arg_type with
      | Arg_term -> Raw arg_name
      | Arg_theorem -> App (Raw "rand", App (Raw "concl", Raw arg_name))
      | Arg_function -> Raw arg_name in
    let final_expr = 
      match app_type with
      | Abs_app _ -> failwith "compile_eval_tree: Abs_app is not allowed"
      | Basic_app _ -> mk_comb "op" full_arg_list
      | Const_app _ | Var_app _ ->
        let args' = map extract_arg full_arg_list in
        let f_name = 
          match app_type with 
          | Const_app f -> f.f_name 
          | Var_app f -> f ^ "_func" 
          | _ -> failwith "impossible" in
        let app_expr = mk_app (Raw f_name, args') in
        if forall (fun (_, ty) -> ty = Arg_term || ty = Arg_function) full_arg_list then app_expr
        else
          let e1 = mk_let ("f_eq", mk_app (Raw f_name, args')) in
          let e2 = mk_comb "op" full_arg_list in
          let e3 = mk_app (Raw "TRANS", [e2; Raw "f_eq"]) in
          append_let_body e1 e3 in
    let arg_eqs =
      zip arg_list args
      |> List.filter (fun ((_, ty), _) -> ty <> Arg_term)
      |> List.map (fun ((name, _), arg) -> mk_let (name, compile name arg)) in
    chain_let (dest_comb name arg_names @ arg_eqs @ [final_expr]), arg_names, extra_names
  in
  let rec compile name t =
    match t with
    | Func_app (Basic_app (Const ("COND", _)), [cond_arg; then_arg; else_arg]) ->
      compile_cond name (compile "cond_tm" cond_arg) (compile "then_tm" then_arg) (compile "else_tm" else_arg)
    | Refl _ -> mk_refl (Raw name)
    | Partial_app (app_type, [], _) when not (is_basic_app t) ->
      let f_name = 
        (match app_type with
        | Var_app name -> name ^ "_func"
        | Const_app rw -> rw.f_name
        | _ -> failwith "Partial_app (Basic_app) is not allowed") in
      mk_tuple [Raw name; Raw f_name]
    | Partial_app (app_type, args, extra_args) ->
      let body_expr, _, extra_names = compile_app compile name app_type args extra_args in
      mk_tuple [Raw name; Lambda (List.map mk_raw extra_names, body_expr)]
    | Func_app (app_type, args) ->
      let body_expr, _, _ = compile_app compile name app_type args [] in
      body_expr
  in
  compile;;

type case_info = {
  f_name: string;
  vars: (term * string) list;
  rhs: eval_tree;
  args: (pattern * arg_type) list;
  th_name: string;
};;

let compile_rhs case =
  let inst =
    List.map (fun tm, var_name -> fst (dest_var tm), var_name) case.vars in
  let inst_expr =
    if inst = [] then Raw case.th_name
    else
      let inst_str = Format.sprintf "[%s]" 
        (String.concat "; " (map (fun (a, b) -> a ^ ", " ^ b) inst)) in
      App (App (Raw "INST", Raw inst_str), Raw case.th_name) in
  if is_eval_tree_refl case.rhs then
    inst_expr
  else
    let expr = compile_eval_tree "rhs" case.rhs in
    chain_let [
      mk_let ("th", inst_expr);
      mk_let ("rhs", Raw "rand (concl th)");
      mk_let ("rhs_eq", expr);
      mk_app (Raw "TRANS", [Raw "th"; Raw "rhs_eq"])
    ];;

let compile_function name cases =
  let compile_case case =
    let var_name i = fst (dest_var (fst (List.nth case.vars i))) in
    let rec compile_pat = function
      | Pvar i, Tfun (args, _) -> mk_tuple [Raw (var_name i); Raw (var_name i ^ "_func")]
      | Pvar i, _ -> Raw (var_name i)
      | Papp _, Tfun _ -> failwith "Patterns are not allowed for functions"
      | Papp (c, ps), ty ->
        let c_name, _ = dest_const c in
        let cst = App (Raw "Const", mk_tuple [String c_name; Raw "_"]) in
        List.fold_left (fun l r -> App (Raw "Comb", Tuple [l; r])) cst 
          (List.map (fun p -> compile_pat (p, ty)) ps) in
    let pats = List.map compile_pat case.args in
    let body = compile_rhs case in
    pats, body
  in
  match List.map compile_case cases with
  | [] -> failwith "compile_function: no cases"
  | [args, body] when forall (function (Pvar _, _) -> true | _ -> false) (hd cases).args ->
    Let (true, name, args, body, None)
  | cs ->
    let arg_names = enum_names "tm" (List.length (hd cases).args) in
    let err_pat = 
      (Raw "_", App (Raw "failwith", String (Format.sprintf "No match: %s" name))) in
    let cs' = List.map (fun (pats, body) -> mk_tuple pats, body) cs in
    let match_expr = Match (mk_tuple (List.map mk_raw arg_names), cs' @ [err_pat]) in
    Let (true, name, List.map mk_raw arg_names, match_expr, None);;

let compile_rules db rules =
  let max_index name =
    flat (map (fun rule -> rule.rewrites) rules)
      |> List.filter (fun r -> r.thm_name = name)
      |> List.fold_left (fun m r -> max m r.thm_index) 0 in
  let get_th_expr name =
    let n = max_index name in
    let names = enum_names (name ^ "_case") n in
    let pat_names = enum_names "th" n in
    mk_let (String.concat ", " names,
      Match (App (Raw "split_thm", Raw name),
        [Raw ("[" ^ String.concat "; " pat_names ^ "]"), mk_tuple (List.map mk_raw pat_names);
         Raw "_", Raw "failwith \"error\""])) in
  let get_var_expr (tm, var_name) =
    let name, ty = dest_var tm in
    let ty_str = Format.sprintf "`:%s`" (string_of_type ty) in
    mk_let (var_name, 
      App (Raw "standardize_tm", 
        App (Raw "mk_var", mk_tuple [String name; Raw ty_str]))) in
  let get_tm_expr tm =
    let ty = type_of tm in
    App (Raw "parse_term", 
      String (Format.sprintf "(%s):%s" (string_of_term tm) (string_of_type ty))) in
  let get_abs_expr (abs_tm, (_, (abs_rw: db_rec), base_tm, base_name)) =
    let args, _ = strip_gabs abs_tm in
    let path = find_path ((=) abs_tm) base_tm in
    let eq_expr = App (Raw "standardize", App (Raw "GEN_BETAS_CONV", Raw "abs_tm")) in
    let def_expr =
      mk_let ~body:(Some eq_expr) ("abs_tm",
        App (Raw "list_mk_comb", 
          mk_tuple [mk_app (Raw "follow_path", [String path; App (Raw "concl", Raw base_name)]);
                    mk_list (map get_tm_expr args)])) in
    mk_let (abs_rw.f_name ^ "_th", def_expr) in
  let vars' = map (fun rule -> map (fun r -> r.fv) rule.rewrites |> flat) rules 
              |> flat |> setify in
  (* TODO: consider types if names coincide *)
  let vars = map (fun v -> v, fst (dest_var v) ^ "_var") vars' in
  let get_case abs f_name rw =
    let rhs = (snd o dest_eq o concl) rw.thm in
    let th_name = Format.sprintf "%s_case%d" rw.thm_name rw.thm_index in
    let eval_tree = build_eval_tree db rhs |> optimize_eval_tree in
    let eval_tree, abs = extract_abs abs (concl rw.thm, th_name) eval_tree in
    let case = {
      f_name = f_name;
      vars = map (fun tm -> find (fun (tm2, _) -> tm = tm2) vars) rw.fv;
      rhs = eval_tree;
      args = zip rw.args rw.arg_types;
      th_name = th_name;
    } in
    case, abs in
  let get_abs_case vars (abs_tm, (abs_body, (abs_rw: db_rec), _, _)) =
    let args, _ = strip_gabs abs_tm in
    let fv, pats = check_args_form args in {
      f_name = abs_rw.f_name;
      vars = map (fun tm -> find (fun (tm2, _) -> tm = tm2) vars) fv;
      rhs = abs_body;
      args = map2 (fun pat arg -> pat, get_type arg) pats args;
      th_name = abs_rw.f_name ^ "_th";
    } in
  let all_cases abs (rule: db_rec) =
    List.fold_left (fun (abs, cases) rw ->
      let case, abs = get_case abs rule.f_name rw in
      (abs, case :: cases)) (abs, []) rule.rewrites in
  let abs, fs = List.fold_left (fun (abs, fs) rule ->
    let abs, cases = all_cases abs rule in
    abs, (rule.f_name, cases) :: fs) ((0, []), []) rules in
  (* Add free variables from abstractions *)
  let vars' = vars' @ 
    flat (map (fun tm, _ ->
      let args, _ = strip_gabs tm in
      flat (map frees args)) (snd abs)) |> setify in
  let vars = map (fun v -> v, fst (dest_var v) ^ "_var") vars' in
  let th_exprs =
    flat (map (fun rule -> rule.rewrites) rules)
      |> map (fun rw -> rw.thm_name)
      |> setify
      |> map get_th_expr in
  let var_exprs = map get_var_expr vars in
  let abs_th_exprs = map get_abs_expr (snd abs) in
  let abs_exprs = map (fun abs ->
    let abs_case = get_abs_case vars abs in
    compile_function abs_case.f_name [abs_case]) (snd abs) in
  let f_names = map fst fs in
  let f_exprs = map (fun (f_name, cases) ->
    compile_function f_name cases) fs in
  let result_expr = mk_tuple (map mk_raw f_names) in
  let main_expr = 
    chain_let (th_exprs @ var_exprs @ abs_th_exprs @ abs_exprs @ [mk_let_and f_exprs; result_expr]) in
  mk_let (String.concat ", " f_names, main_expr);;


(*
let compile_rule db rw =
  let c_name, _ = dest_const rw.const in
  let arg_names = enum_names "tm" rw.nargs in
  let err_pat = 
    (Raw "_", App (Raw "failwith", String (Format.sprintf "No match: %s" c_name))) in
  let match_e = Match (mk_tuple (List.map mk_raw arg_names), 
                     List.map (compile_case db) rw.rewrites @ [err_pat]) in
  let top_e = Let (true, rw.f_name, arg_names, match_e, Some (Raw rw.f_name)) in
  let prelude = append_let_body (compile_prelude rw) top_e in
  Let (false, rw.f_name, [], prelude, None);;

let compile_term db f_name tm =
  let eval_tree = build_eval_tree db tm |> optimize_eval_tree in
  let expr = compile_eval_tree "tm" eval_tree in
  mk_let (f_name, mk_let ~body:(Some expr) ("tm", Term tm));;
*)
