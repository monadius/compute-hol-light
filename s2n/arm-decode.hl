(* Set the load_path and load "arm/proofs/base.ml";; *)
needs "s2n/load-arm.hl";;

(** BITMATCH_CONV is slow because it needs to construct
    a discrimination tree every time BITMATCH_CONV is invoked.
    This conversion memoizes discrimination trees so it works
    much faster when it is called several times for the same bitmatch 
    pattern. *)
let bitmatch_memo_conv =
  let tree_memo = Hashtbl.create 64 in
  function
  | Comb(Comb((Const("_BITMATCH",_) as e),(Comb(Const("word",ty), n_tm))),cs) ->
    let w_ty = snd (dest_fun_ty ty) in
    let size = Num.int_of_num (dest_finty (dest_word_ty w_ty)) in
    let tr = 
      try Hashtbl.find tree_memo cs
      with Not_found -> 
        let w_var = mk_var ("$w", w_ty) in
        let w_tm = list_mk_comb (e, [w_var; cs]) in
        let _, tr = bm_build_pos_tree w_tm in
        Hashtbl.add tree_memo cs tr;
        tr in
    let nn = dest_numeral n_tm in
    let n = Num.int_of_num nn in
    let arr = Array.init size (fun i -> Some (n land (1 lsl i) != 0)) in
    let th = hd (snd (snd (get_dt arr tr))) in
    let ls, th' = inst_bitpat_numeral (hd (hyp th)) nn in
    PROVE_HYP th' (INST ls th)
  | _ -> failwith "bitmatch_memo_conv";;

open Compute;;

prioritize_num();;

let decode_rw = 
  let rw = bool_compset() in
  add_conv (`_BITMATCH`, 2, bitmatch_memo_conv) rw;
  add_thms [decode] rw;
  List.iter (fun tm -> add_conv (tm, 1, REG_CONV) rw) [`XREG'`; `WREG'`; `QREG'`; `DREG'`; `XREG_SP`; `WREG_SP`];
  add_thms [arm_adcop; arm_addop; arm_logop; arm_movop; arm_csop; arm_lsvop; arm_ccop; arm_bfmop; arm_ldst; arm_ldst_q; arm_ldst_d; arm_ldstb; arm_ldstp; arm_ldstp_d; arm_adv_simd_expand_imm] rw;
  add_conv (`bit`, 2, WORD_RED_CONV) rw;
  add_thms [decode_shift; decode_extendtype];
  add_conv (`decode_bitmask`, 3, DECODE_BITMASK_CONV) rw;
  List.iter (fun tm -> add_conv (tm, 1, WORD_RED_CONV) rw) [`word_clz`; `word_ctz`; `word_zx`; `word_sx`; `word_not`];
  List.iter (fun tm -> add_conv (tm, 2, WORD_RED_CONV) rw) [`word_join`; `word_sub`; `word_subword`];
  add_conv (`(=):N word -> N word -> bool`, 2, WORD_RED_CONV) rw;
  List.iter (fun tm -> add_conv (tm, 2, NUM_RED_CONV) rw) [`(=):num -> num -> bool`; `<=`; `>=`; `<`; `>`; `*`; `+`; `-`; `DIV`; `EXP`];
  add_conv (`val`, 1, WORD_RED_CONV) rw;
  add_conv (`ival`, 1, WORD_RED_CONV) rw;
  rw;;

let tm = `decode (word 0x8b010003:int32)`;;
time (CBV_CONV decode_rw) tm;;
time PURE_DECODE_CONV tm;;

let tm = `decode (word 0x385ff422:int32)`;;
time (CBV_CONV decode_rw) tm;;
time PURE_DECODE_CONV tm;;


